// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: schema.proto

package schema

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import protocol "github.com/LiveRamp/gazette/v2/pkg/protocol"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/golang/protobuf/ptypes/duration"
import _ "github.com/golang/protobuf/ptypes/timestamp"

import time "time"

import encoding_binary "encoding/binary"
import github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type DimensionType int32

const (
	DimensionType_INVALID_DIM_TYPE DimensionType = 0
	DimensionType_VARINT           DimensionType = 1
	DimensionType_FLOAT            DimensionType = 3
	DimensionType_STRING           DimensionType = 4
	DimensionType_TIMESTAMP        DimensionType = 5
)

var DimensionType_name = map[int32]string{
	0: "INVALID_DIM_TYPE",
	1: "VARINT",
	3: "FLOAT",
	4: "STRING",
	5: "TIMESTAMP",
}
var DimensionType_value = map[string]int32{
	"INVALID_DIM_TYPE": 0,
	"VARINT":           1,
	"FLOAT":            3,
	"STRING":           4,
	"TIMESTAMP":        5,
}

func (x DimensionType) String() string {
	return proto.EnumName(DimensionType_name, int32(x))
}
func (DimensionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{0}
}

type MetricType int32

const (
	MetricType_INVALID_METRIC_TYPE MetricType = 0
	MetricType_VARINT_SUM          MetricType = 1
	MetricType_VARINT_GUAGE        MetricType = 2
	MetricType_FLOAT_SUM           MetricType = 3
	MetricType_STRING_HLL          MetricType = 4
)

var MetricType_name = map[int32]string{
	0: "INVALID_METRIC_TYPE",
	1: "VARINT_SUM",
	2: "VARINT_GUAGE",
	3: "FLOAT_SUM",
	4: "STRING_HLL",
}
var MetricType_value = map[string]int32{
	"INVALID_METRIC_TYPE": 0,
	"VARINT_SUM":          1,
	"VARINT_GUAGE":        2,
	"FLOAT_SUM":           3,
	"STRING_HLL":          4,
}

func (x MetricType) String() string {
	return proto.EnumName(MetricType_name, int32(x))
}
func (MetricType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{1}
}

// MappingSpec specifies a Mapping of input Messages to InputRecords.
type MappingSpec struct {
	// Unique tag of the Mapping. Immutable.
	Tag MapTag `protobuf:"varint,1,opt,name=tag,proto3,casttype=MapTag" json:"tag,omitempty"`
	// Short, unique name of the Mapping.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Longer, free-form description of the Mapping.
	Desc                 string   `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MappingSpec) Reset()         { *m = MappingSpec{} }
func (m *MappingSpec) String() string { return proto.CompactTextString(m) }
func (*MappingSpec) ProtoMessage()    {}
func (*MappingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{0}
}
func (m *MappingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MappingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingSpec.Merge(dst, src)
}
func (m *MappingSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MappingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MappingSpec proto.InternalMessageInfo

func (m *MappingSpec) GetTag() MapTag {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *MappingSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MappingSpec) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

// DimensionSpec specifies a semantic dimension which may be extracted from
// InputRecords.
type DimensionSpec struct {
	// Unique tag of the dimension. Immutable.
	Tag DimTag `protobuf:"varint,1,opt,name=tag,proto3,casttype=DimTag" json:"tag,omitempty"`
	// Type of the Dimension. Immutable.
	Type DimensionType `protobuf:"varint,2,opt,name=type,proto3,enum=schema.DimensionType" json:"type,omitempty"`
	// Short, unique name of the Dimension.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Longer, free-form description of the Dimension.
	Desc                 string   `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DimensionSpec) Reset()         { *m = DimensionSpec{} }
func (m *DimensionSpec) String() string { return proto.CompactTextString(m) }
func (*DimensionSpec) ProtoMessage()    {}
func (*DimensionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{1}
}
func (m *DimensionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DimensionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DimensionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DimensionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DimensionSpec.Merge(dst, src)
}
func (m *DimensionSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DimensionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DimensionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DimensionSpec proto.InternalMessageInfo

func (m *DimensionSpec) GetTag() DimTag {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *DimensionSpec) GetType() DimensionType {
	if m != nil {
		return m.Type
	}
	return DimensionType_INVALID_DIM_TYPE
}

func (m *DimensionSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DimensionSpec) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

// MetricSpec specifies a semantic metric which may be derived from
// a specified dimension.
type MetricSpec struct {
	// Unique tag of the Metric. Immutable.
	Tag MetTag `protobuf:"varint,1,opt,name=tag,proto3,casttype=MetTag" json:"tag,omitempty"`
	// Type of the Metric. Immutable.
	Type MetricType `protobuf:"varint,2,opt,name=type,proto3,enum=schema.MetricType" json:"type,omitempty"`
	// Dimension tag from which the Metric is extracted.
	DimTag DimTag `protobuf:"varint,3,opt,name=dim_tag,json=dimTag,proto3,casttype=DimTag" json:"dim_tag,omitempty"`
	// Short, unique name of the Metric.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// Longer, free-form description of the Metric.
	Desc                 string   `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetricSpec) Reset()         { *m = MetricSpec{} }
func (m *MetricSpec) String() string { return proto.CompactTextString(m) }
func (*MetricSpec) ProtoMessage()    {}
func (*MetricSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{2}
}
func (m *MetricSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MetricSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricSpec.Merge(dst, src)
}
func (m *MetricSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MetricSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MetricSpec proto.InternalMessageInfo

func (m *MetricSpec) GetTag() MetTag {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *MetricSpec) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return MetricType_INVALID_METRIC_TYPE
}

func (m *MetricSpec) GetDimTag() DimTag {
	if m != nil {
		return m.DimTag
	}
	return 0
}

func (m *MetricSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetricSpec) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

// Shape describes the structure of a collection of records.
type Shape struct {
	// Ordered Dimensions of each row.
	Dimensions []DimTag `protobuf:"varint,2,rep,packed,name=dimensions,casttype=DimTag" json:"dimensions,omitempty"`
	// Ordered Metrics of each row.
	Metrics              []MetTag `protobuf:"varint,3,rep,packed,name=metrics,casttype=MetTag" json:"metrics,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Shape) Reset()         { *m = Shape{} }
func (m *Shape) String() string { return proto.CompactTextString(m) }
func (*Shape) ProtoMessage()    {}
func (*Shape) Descriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{3}
}
func (m *Shape) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Shape) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Shape.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Shape) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Shape.Merge(dst, src)
}
func (m *Shape) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Shape) XXX_DiscardUnknown() {
	xxx_messageInfo_Shape.DiscardUnknown(m)
}

var xxx_messageInfo_Shape proto.InternalMessageInfo

func (m *Shape) GetDimensions() []DimTag {
	if m != nil {
		return m.Dimensions
	}
	return nil
}

func (m *Shape) GetMetrics() []MetTag {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// RelationSpec describes a combination of a Mapping, Dimensions, and Metrics.
// Relations are incrementally built by processing input Tuples through the
// Mapping, and extracting unique keys by composing the result of each Dimension
// extractor. Metrics of each mapped Tuple is then folded on its unique key
// to produce Relation Aggregates.
type RelationSpec struct {
	// Unique tag of the Relation. Immutable.
	Tag RelTag `protobuf:"varint,1,opt,name=tag,proto3,casttype=RelTag" json:"tag,omitempty"`
	// Short, unique name of the Relation.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Longer, free-form description of the Relation.
	Desc string `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	// LabelSelector identifies journals processed by this Relation.
	Selector protocol.LabelSelector `protobuf:"bytes,4,opt,name=selector" json:"selector"`
	// Mapping applied to input events.
	Mapping MapTag `protobuf:"varint,5,opt,name=mapping,proto3,casttype=MapTag" json:"mapping,omitempty"`
	// Shape of the Relation. Immutable.
	Shape                `protobuf:"bytes,6,opt,name=shape,embedded=shape" json:"shape"`
	Retention            *RelationSpec_Retention `protobuf:"bytes,7,opt,name=retention" json:"retention,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *RelationSpec) Reset()         { *m = RelationSpec{} }
func (m *RelationSpec) String() string { return proto.CompactTextString(m) }
func (*RelationSpec) ProtoMessage()    {}
func (*RelationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{4}
}
func (m *RelationSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelationSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RelationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelationSpec.Merge(dst, src)
}
func (m *RelationSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RelationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RelationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RelationSpec proto.InternalMessageInfo

func (m *RelationSpec) GetTag() RelTag {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *RelationSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RelationSpec) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *RelationSpec) GetSelector() protocol.LabelSelector {
	if m != nil {
		return m.Selector
	}
	return protocol.LabelSelector{}
}

func (m *RelationSpec) GetMapping() MapTag {
	if m != nil {
		return m.Mapping
	}
	return 0
}

func (m *RelationSpec) GetRetention() *RelationSpec_Retention {
	if m != nil {
		return m.Retention
	}
	return nil
}

// Optional Retention of Relation rows.
type RelationSpec_Retention struct {
	// Duration after which a row is eligible for removal.
	RemoveAfter time.Duration `protobuf:"bytes,1,opt,name=remove_after,json=removeAfter,stdduration" json:"remove_after"`
	// Dimension, which must be part of the Relation and of type Timestamp,
	// to which |remove_after| is added to determine the effective removal
	// horizon.
	RelativeTo           DimTag   `protobuf:"varint,2,opt,name=relative_to,json=relativeTo,proto3,casttype=DimTag" json:"relative_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RelationSpec_Retention) Reset()         { *m = RelationSpec_Retention{} }
func (m *RelationSpec_Retention) String() string { return proto.CompactTextString(m) }
func (*RelationSpec_Retention) ProtoMessage()    {}
func (*RelationSpec_Retention) Descriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{4, 0}
}
func (m *RelationSpec_Retention) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelationSpec_Retention) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelationSpec_Retention.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RelationSpec_Retention) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelationSpec_Retention.Merge(dst, src)
}
func (m *RelationSpec_Retention) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RelationSpec_Retention) XXX_DiscardUnknown() {
	xxx_messageInfo_RelationSpec_Retention.DiscardUnknown(m)
}

var xxx_messageInfo_RelationSpec_Retention proto.InternalMessageInfo

func (m *RelationSpec_Retention) GetRemoveAfter() time.Duration {
	if m != nil {
		return m.RemoveAfter
	}
	return 0
}

func (m *RelationSpec_Retention) GetRelativeTo() DimTag {
	if m != nil {
		return m.RelativeTo
	}
	return 0
}

// Config of a set of Relations and their Metrics, Dimensions, and Mappings.
// The complete Config must be referentially consistent: any Mapping, Dimension
// or Metric used in a Relation must be defined. Similarly, Dimensions
// referenced from Metrics must be defined, and of the proper associated type.
type Config struct {
	Mappings             []MappingSpec   `protobuf:"bytes,1,rep,name=mappings" json:"mappings"`
	Dimensions           []DimensionSpec `protobuf:"bytes,2,rep,name=dimensions" json:"dimensions"`
	Metrics              []MetricSpec    `protobuf:"bytes,3,rep,name=metrics" json:"metrics"`
	Relations            []RelationSpec  `protobuf:"bytes,4,rep,name=relations" json:"relations"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{5}
}
func (m *Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(dst, src)
}
func (m *Config) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

func (m *Config) GetMappings() []MappingSpec {
	if m != nil {
		return m.Mappings
	}
	return nil
}

func (m *Config) GetDimensions() []DimensionSpec {
	if m != nil {
		return m.Dimensions
	}
	return nil
}

func (m *Config) GetMetrics() []MetricSpec {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *Config) GetRelations() []RelationSpec {
	if m != nil {
		return m.Relations
	}
	return nil
}

// QuerySpec describes a result which should be computed from a Relation.
// In particular it defines the "shape" (in Dimensions and Metrics) of the
// desired result, and any filters which should be applied.
type QuerySpec struct {
	// Shape of the Query result.
	//
	// Dimensions of the underlying Relation which should be grouped over and
	// returned with the Query result set. Other Dimensions of the relation not
	// included in the Query Shape are aggregated across.
	//
	// Where possible, use a strict ordered prefix of underlying Relation
	// Dimensions. This is much more efficient to evaluate, as grouping can
	// utilize the natural index order, and no further recombining or sorting is
	// required. When using a prefix, the Query result set is incrementally
	// streamed as it is evaluated, and even extremely large result sets can be
	// queried efficiently.
	//
	// If Dimensions are not a strict prefix, the Query evaluator must perform
	// recombination and sorting steps, and results will be sent only after
	// all underlying table rows have been read. Implementations may also limit
	// the size of the result sets they will buffer, returning an error for
	// Queries which exceed it.
	Shape                `protobuf:"bytes,1,opt,name=shape,embedded=shape" json:"shape"`
	Filters              []QuerySpec_Filter `protobuf:"bytes,2,rep,name=filters" json:"filters"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *QuerySpec) Reset()         { *m = QuerySpec{} }
func (m *QuerySpec) String() string { return proto.CompactTextString(m) }
func (*QuerySpec) ProtoMessage()    {}
func (*QuerySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{6}
}
func (m *QuerySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QuerySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpec.Merge(dst, src)
}
func (m *QuerySpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *QuerySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpec.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpec proto.InternalMessageInfo

func (m *QuerySpec) GetFilters() []QuerySpec_Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// A Filter is a sequence of ordered non-overlapping ranges for a dimension.
// Filters may be applied to any subset of relation dimensions, including
// those not present in the Query Relation.
type QuerySpec_Filter struct {
	// Dimension to which the filter is applied.
	Dimension DimTag `protobuf:"varint,1,opt,name=dimension,proto3,casttype=DimTag" json:"dimension,omitempty"`
	// Admissible Dimension ranges. The subtype of each Range must match that
	// of the Relation Dimension itself.
	Ranges               []Range  `protobuf:"bytes,2,rep,name=ranges" json:"ranges"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QuerySpec_Filter) Reset()         { *m = QuerySpec_Filter{} }
func (m *QuerySpec_Filter) String() string { return proto.CompactTextString(m) }
func (*QuerySpec_Filter) ProtoMessage()    {}
func (*QuerySpec_Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{6, 0}
}
func (m *QuerySpec_Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpec_Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpec_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QuerySpec_Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpec_Filter.Merge(dst, src)
}
func (m *QuerySpec_Filter) XXX_Size() int {
	return m.ProtoSize()
}
func (m *QuerySpec_Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpec_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpec_Filter proto.InternalMessageInfo

func (m *QuerySpec_Filter) GetDimension() DimTag {
	if m != nil {
		return m.Dimension
	}
	return 0
}

func (m *QuerySpec_Filter) GetRanges() []Range {
	if m != nil {
		return m.Ranges
	}
	return nil
}

// Range is Begin & End values (inclusive) as a union type. If Begin is omitted,
// it is interpreted as matching any lesser value. Similarly if End is omitted,
// it is interpreted as matching any greater value.
type Range struct {
	Int                  *Range_Int       `protobuf:"bytes,2,opt,name=int" json:"int,omitempty"`
	Float                *Range_Float     `protobuf:"bytes,3,opt,name=float" json:"float,omitempty"`
	String_              *Range_String    `protobuf:"bytes,4,opt,name=string" json:"string,omitempty"`
	Timestamp            *Range_Timestamp `protobuf:"bytes,5,opt,name=timestamp" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{7}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(dst, src)
}
func (m *Range) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetInt() *Range_Int {
	if m != nil {
		return m.Int
	}
	return nil
}

func (m *Range) GetFloat() *Range_Float {
	if m != nil {
		return m.Float
	}
	return nil
}

func (m *Range) GetString_() *Range_String {
	if m != nil {
		return m.String_
	}
	return nil
}

func (m *Range) GetTimestamp() *Range_Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type Range_Int struct {
	Begin                int64    `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End                  int64    `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Range_Int) Reset()         { *m = Range_Int{} }
func (m *Range_Int) String() string { return proto.CompactTextString(m) }
func (*Range_Int) ProtoMessage()    {}
func (*Range_Int) Descriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{7, 0}
}
func (m *Range_Int) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range_Int) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range_Int.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Range_Int) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range_Int.Merge(dst, src)
}
func (m *Range_Int) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Range_Int) XXX_DiscardUnknown() {
	xxx_messageInfo_Range_Int.DiscardUnknown(m)
}

var xxx_messageInfo_Range_Int proto.InternalMessageInfo

func (m *Range_Int) GetBegin() int64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *Range_Int) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

type Range_Float struct {
	Begin                float64  `protobuf:"fixed64,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End                  float64  `protobuf:"fixed64,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Range_Float) Reset()         { *m = Range_Float{} }
func (m *Range_Float) String() string { return proto.CompactTextString(m) }
func (*Range_Float) ProtoMessage()    {}
func (*Range_Float) Descriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{7, 1}
}
func (m *Range_Float) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range_Float) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range_Float.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Range_Float) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range_Float.Merge(dst, src)
}
func (m *Range_Float) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Range_Float) XXX_DiscardUnknown() {
	xxx_messageInfo_Range_Float.DiscardUnknown(m)
}

var xxx_messageInfo_Range_Float proto.InternalMessageInfo

func (m *Range_Float) GetBegin() float64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *Range_Float) GetEnd() float64 {
	if m != nil {
		return m.End
	}
	return 0
}

type Range_String struct {
	Begin                string   `protobuf:"bytes,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End                  string   `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Range_String) Reset()         { *m = Range_String{} }
func (m *Range_String) String() string { return proto.CompactTextString(m) }
func (*Range_String) ProtoMessage()    {}
func (*Range_String) Descriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{7, 2}
}
func (m *Range_String) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range_String) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range_String.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Range_String) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range_String.Merge(dst, src)
}
func (m *Range_String) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Range_String) XXX_DiscardUnknown() {
	xxx_messageInfo_Range_String.DiscardUnknown(m)
}

var xxx_messageInfo_Range_String proto.InternalMessageInfo

func (m *Range_String) GetBegin() string {
	if m != nil {
		return m.Begin
	}
	return ""
}

func (m *Range_String) GetEnd() string {
	if m != nil {
		return m.End
	}
	return ""
}

// Timestamp may be specified in Unix epoch seconds, or as a Timestamp.
// Only one variant may be used.
type Range_Timestamp struct {
	BeginUnix            int64     `protobuf:"varint,1,opt,name=begin_unix,json=beginUnix,proto3" json:"begin_unix,omitempty"`
	EndUnix              int64     `protobuf:"varint,2,opt,name=end_unix,json=endUnix,proto3" json:"end_unix,omitempty"`
	Begin                time.Time `protobuf:"bytes,3,opt,name=begin,stdtime" json:"begin"`
	End                  time.Time `protobuf:"bytes,4,opt,name=end,stdtime" json:"end"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Range_Timestamp) Reset()         { *m = Range_Timestamp{} }
func (m *Range_Timestamp) String() string { return proto.CompactTextString(m) }
func (*Range_Timestamp) ProtoMessage()    {}
func (*Range_Timestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_schema_0d4d1c4229e380e8, []int{7, 3}
}
func (m *Range_Timestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range_Timestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range_Timestamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Range_Timestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range_Timestamp.Merge(dst, src)
}
func (m *Range_Timestamp) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Range_Timestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_Range_Timestamp.DiscardUnknown(m)
}

var xxx_messageInfo_Range_Timestamp proto.InternalMessageInfo

func (m *Range_Timestamp) GetBeginUnix() int64 {
	if m != nil {
		return m.BeginUnix
	}
	return 0
}

func (m *Range_Timestamp) GetEndUnix() int64 {
	if m != nil {
		return m.EndUnix
	}
	return 0
}

func (m *Range_Timestamp) GetBegin() time.Time {
	if m != nil {
		return m.Begin
	}
	return time.Time{}
}

func (m *Range_Timestamp) GetEnd() time.Time {
	if m != nil {
		return m.End
	}
	return time.Time{}
}

func init() {
	proto.RegisterType((*MappingSpec)(nil), "schema.MappingSpec")
	proto.RegisterType((*DimensionSpec)(nil), "schema.DimensionSpec")
	proto.RegisterType((*MetricSpec)(nil), "schema.MetricSpec")
	proto.RegisterType((*Shape)(nil), "schema.Shape")
	proto.RegisterType((*RelationSpec)(nil), "schema.RelationSpec")
	proto.RegisterType((*RelationSpec_Retention)(nil), "schema.RelationSpec.Retention")
	proto.RegisterType((*Config)(nil), "schema.Config")
	proto.RegisterType((*QuerySpec)(nil), "schema.QuerySpec")
	proto.RegisterType((*QuerySpec_Filter)(nil), "schema.QuerySpec.Filter")
	proto.RegisterType((*Range)(nil), "schema.Range")
	proto.RegisterType((*Range_Int)(nil), "schema.Range.Int")
	proto.RegisterType((*Range_Float)(nil), "schema.Range.Float")
	proto.RegisterType((*Range_String)(nil), "schema.Range.String")
	proto.RegisterType((*Range_Timestamp)(nil), "schema.Range.Timestamp")
	proto.RegisterEnum("schema.DimensionType", DimensionType_name, DimensionType_value)
	proto.RegisterEnum("schema.MetricType", MetricType_name, MetricType_value)
}
func (m *MappingSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Tag))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DimensionSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DimensionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Tag))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MetricSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Tag))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Type))
	}
	if m.DimTag != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.DimTag))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Shape) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shape) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dimensions) > 0 {
		dAtA2 := make([]byte, len(m.Dimensions)*10)
		var j1 int
		for _, num1 := range m.Dimensions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintSchema(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.Metrics) > 0 {
		dAtA4 := make([]byte, len(m.Metrics)*10)
		var j3 int
		for _, num1 := range m.Metrics {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RelationSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Tag))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintSchema(dAtA, i, uint64(m.Selector.ProtoSize()))
	n5, err := m.Selector.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.Mapping != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Mapping))
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintSchema(dAtA, i, uint64(m.Shape.ProtoSize()))
	n6, err := m.Shape.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if m.Retention != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Retention.ProtoSize()))
		n7, err := m.Retention.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RelationSpec_Retention) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationSpec_Retention) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSchema(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.RemoveAfter)))
	n8, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.RemoveAfter, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if m.RelativeTo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.RelativeTo))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mappings) > 0 {
		for _, msg := range m.Mappings {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSchema(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Dimensions) > 0 {
		for _, msg := range m.Dimensions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSchema(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Metrics) > 0 {
		for _, msg := range m.Metrics {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintSchema(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Relations) > 0 {
		for _, msg := range m.Relations {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSchema(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QuerySpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSchema(dAtA, i, uint64(m.Shape.ProtoSize()))
	n9, err := m.Shape.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.Filters) > 0 {
		for _, msg := range m.Filters {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSchema(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QuerySpec_Filter) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpec_Filter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dimension != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Dimension))
	}
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSchema(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Int != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Int.ProtoSize()))
		n10, err := m.Int.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Float != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Float.ProtoSize()))
		n11, err := m.Float.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.String_ != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.String_.ProtoSize()))
		n12, err := m.String_.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Timestamp.ProtoSize()))
		n13, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Range_Int) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range_Int) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Begin != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Begin))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.End))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Range_Float) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range_Float) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Begin != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Begin))))
		i += 8
	}
	if m.End != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.End))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Range_String) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range_String) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Begin) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Begin)))
		i += copy(dAtA[i:], m.Begin)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Range_Timestamp) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range_Timestamp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BeginUnix != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.BeginUnix))
	}
	if m.EndUnix != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.EndUnix))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSchema(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.Begin)))
	n14, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Begin, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x22
	i++
	i = encodeVarintSchema(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.End)))
	n15, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.End, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintSchema(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MappingSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovSchema(uint64(m.Tag))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DimensionSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovSchema(uint64(m.Tag))
	}
	if m.Type != 0 {
		n += 1 + sovSchema(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetricSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovSchema(uint64(m.Tag))
	}
	if m.Type != 0 {
		n += 1 + sovSchema(uint64(m.Type))
	}
	if m.DimTag != 0 {
		n += 1 + sovSchema(uint64(m.DimTag))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Shape) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dimensions) > 0 {
		l = 0
		for _, e := range m.Dimensions {
			l += sovSchema(uint64(e))
		}
		n += 1 + sovSchema(uint64(l)) + l
	}
	if len(m.Metrics) > 0 {
		l = 0
		for _, e := range m.Metrics {
			l += sovSchema(uint64(e))
		}
		n += 1 + sovSchema(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RelationSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovSchema(uint64(m.Tag))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = m.Selector.ProtoSize()
	n += 1 + l + sovSchema(uint64(l))
	if m.Mapping != 0 {
		n += 1 + sovSchema(uint64(m.Mapping))
	}
	l = m.Shape.ProtoSize()
	n += 1 + l + sovSchema(uint64(l))
	if m.Retention != nil {
		l = m.Retention.ProtoSize()
		n += 1 + l + sovSchema(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RelationSpec_Retention) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.RemoveAfter)
	n += 1 + l + sovSchema(uint64(l))
	if m.RelativeTo != 0 {
		n += 1 + sovSchema(uint64(m.RelativeTo))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Config) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Mappings) > 0 {
		for _, e := range m.Mappings {
			l = e.ProtoSize()
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	if len(m.Dimensions) > 0 {
		for _, e := range m.Dimensions {
			l = e.ProtoSize()
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.ProtoSize()
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	if len(m.Relations) > 0 {
		for _, e := range m.Relations {
			l = e.ProtoSize()
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QuerySpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Shape.ProtoSize()
	n += 1 + l + sovSchema(uint64(l))
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.ProtoSize()
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QuerySpec_Filter) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dimension != 0 {
		n += 1 + sovSchema(uint64(m.Dimension))
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.ProtoSize()
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Range) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Int != nil {
		l = m.Int.ProtoSize()
		n += 1 + l + sovSchema(uint64(l))
	}
	if m.Float != nil {
		l = m.Float.ProtoSize()
		n += 1 + l + sovSchema(uint64(l))
	}
	if m.String_ != nil {
		l = m.String_.ProtoSize()
		n += 1 + l + sovSchema(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.ProtoSize()
		n += 1 + l + sovSchema(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Range_Int) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != 0 {
		n += 1 + sovSchema(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovSchema(uint64(m.End))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Range_Float) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != 0 {
		n += 9
	}
	if m.End != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Range_String) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Begin)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Range_Timestamp) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BeginUnix != 0 {
		n += 1 + sovSchema(uint64(m.BeginUnix))
	}
	if m.EndUnix != 0 {
		n += 1 + sovSchema(uint64(m.EndUnix))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Begin)
	n += 1 + l + sovSchema(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.End)
	n += 1 + l + sovSchema(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSchema(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSchema(x uint64) (n int) {
	return sovSchema(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MappingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= (MapTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DimensionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DimensionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DimensionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= (DimTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (DimensionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= (MetTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MetricType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DimTag", wireType)
			}
			m.DimTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DimTag |= (DimTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shape) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shape: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shape: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v DimTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchema
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (DimTag(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dimensions = append(m.Dimensions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchema
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSchema
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Dimensions) == 0 {
					m.Dimensions = make([]DimTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v DimTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchema
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (DimTag(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dimensions = append(m.Dimensions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimensions", wireType)
			}
		case 3:
			if wireType == 0 {
				var v MetTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchema
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (MetTag(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Metrics = append(m.Metrics, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchema
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSchema
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Metrics) == 0 {
					m.Metrics = make([]MetTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v MetTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchema
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (MetTag(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Metrics = append(m.Metrics, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= (RelTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mapping", wireType)
			}
			m.Mapping = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mapping |= (MapTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retention", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Retention == nil {
				m.Retention = &RelationSpec_Retention{}
			}
			if err := m.Retention.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationSpec_Retention) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Retention: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Retention: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.RemoveAfter, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeTo", wireType)
			}
			m.RelativeTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelativeTo |= (DimTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mappings = append(m.Mappings, MappingSpec{})
			if err := m.Mappings[len(m.Mappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dimensions = append(m.Dimensions, DimensionSpec{})
			if err := m.Dimensions[len(m.Dimensions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, MetricSpec{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relations = append(m.Relations, RelationSpec{})
			if err := m.Relations[len(m.Relations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, QuerySpec_Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpec_Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimension", wireType)
			}
			m.Dimension = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dimension |= (DimTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, Range{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Int == nil {
				m.Int = &Range_Int{}
			}
			if err := m.Int.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Float == nil {
				m.Float = &Range_Float{}
			}
			if err := m.Float.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.String_ == nil {
				m.String_ = &Range_String{}
			}
			if err := m.String_.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Range_Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range_Int) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range_Float) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Float: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Float: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Begin = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.End = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range_String) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: String: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: String: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Begin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range_Timestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginUnix", wireType)
			}
			m.BeginUnix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginUnix |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndUnix", wireType)
			}
			m.EndUnix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndUnix |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Begin, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.End, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSchema(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSchema
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSchema
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSchema(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSchema = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSchema   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("schema.proto", fileDescriptor_schema_0d4d1c4229e380e8) }

var fileDescriptor_schema_0d4d1c4229e380e8 = []byte{
	// 1016 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0xce, 0x9a, 0x3f, 0x16, 0x47, 0x76, 0xc0, 0x6e, 0x5c, 0x84, 0x11, 0x5a, 0xdb, 0x50, 0x8a,
	0xc2, 0x71, 0x6a, 0xaa, 0x50, 0x91, 0x22, 0x4d, 0x7b, 0x91, 0xe3, 0x9f, 0x2a, 0x90, 0xdc, 0x74,
	0x45, 0xa7, 0xe8, 0x49, 0xa0, 0xa5, 0x15, 0x4d, 0x54, 0xfc, 0x01, 0xb9, 0x36, 0xe2, 0x9e, 0xf2,
	0x08, 0x39, 0xf6, 0xd6, 0x5e, 0xfa, 0x10, 0x7d, 0x83, 0x1c, 0x73, 0xe9, 0xd5, 0x05, 0xd2, 0x5b,
	0x1f, 0xa1, 0xa7, 0x62, 0x77, 0xb9, 0x14, 0x65, 0xcb, 0x40, 0x73, 0x12, 0xb9, 0xdf, 0xf7, 0xcd,
	0x7c, 0x33, 0x3b, 0x23, 0xc2, 0x4a, 0x3e, 0x3a, 0xa5, 0x91, 0xef, 0xa6, 0x59, 0xc2, 0x12, 0x6c,
	0xca, 0xb7, 0xc6, 0x4e, 0x10, 0xb2, 0xd3, 0xb3, 0x13, 0x77, 0x94, 0x44, 0xad, 0x20, 0x09, 0x92,
	0x96, 0x80, 0x4f, 0xce, 0x26, 0xe2, 0x4d, 0xbc, 0x88, 0x27, 0x29, 0x6b, 0x3c, 0xa9, 0xd0, 0x7b,
	0xe1, 0x39, 0x25, 0x7e, 0x94, 0xb6, 0x02, 0xff, 0x67, 0xca, 0x18, 0x6d, 0x9d, 0xb7, 0x5b, 0xe9,
	0x4f, 0x81, 0x8c, 0x30, 0x4a, 0xa6, 0xe5, 0x43, 0xa1, 0x5d, 0x0f, 0x92, 0x24, 0x98, 0xd2, 0x59,
	0x86, 0xf1, 0x59, 0xe6, 0xb3, 0x30, 0x89, 0x0b, 0x7c, 0xe3, 0x2a, 0xce, 0xc2, 0x88, 0xe6, 0xcc,
	0x8f, 0x52, 0x49, 0x68, 0x0e, 0xa0, 0xde, 0xf7, 0xd3, 0x34, 0x8c, 0x83, 0x41, 0x4a, 0x47, 0xf8,
	0x23, 0xd0, 0x98, 0x1f, 0x38, 0x68, 0x13, 0x6d, 0x69, 0xbb, 0xf0, 0xef, 0xe5, 0x86, 0xd9, 0xf7,
	0x53, 0xcf, 0x0f, 0x08, 0x3f, 0xc6, 0x18, 0xf4, 0xd8, 0x8f, 0xa8, 0xb3, 0xb4, 0x89, 0xb6, 0x2c,
	0x22, 0x9e, 0xf9, 0xd9, 0x98, 0xe6, 0x23, 0x47, 0x93, 0x67, 0xfc, 0xb9, 0xf9, 0x0a, 0xc1, 0xea,
	0x5e, 0x18, 0xd1, 0x38, 0x0f, 0x93, 0xf8, 0x86, 0xb8, 0x7b, 0x61, 0x54, 0xc6, 0x7d, 0x00, 0x3a,
	0xbb, 0x48, 0x65, 0xdc, 0xdb, 0xed, 0x0f, 0xdd, 0xa2, 0xab, 0x65, 0x08, 0xef, 0x22, 0xa5, 0x44,
	0x50, 0x4a, 0x0b, 0xda, 0x02, 0x0b, 0x7a, 0xc5, 0xc2, 0xaf, 0x08, 0xa0, 0x4f, 0x59, 0x16, 0x8e,
	0x6e, 0xaa, 0x8b, 0xb2, 0x32, 0xff, 0xa7, 0x73, 0xf9, 0xb1, 0xca, 0x2f, 0xf5, 0x95, 0xe4, 0xf7,
	0x61, 0x79, 0x1c, 0x46, 0x43, 0x1e, 0x49, 0xbb, 0x56, 0x89, 0x39, 0x16, 0xbf, 0xa5, 0x43, 0x7d,
	0x81, 0x43, 0xa3, 0xe2, 0x90, 0x82, 0x31, 0x38, 0xf5, 0x53, 0x8a, 0xb7, 0x01, 0xc6, 0xaa, 0xd2,
	0xdc, 0x59, 0xda, 0xd4, 0xae, 0x04, 0xae, 0xa0, 0xf8, 0x13, 0x58, 0x8e, 0x84, 0xab, 0xdc, 0xd1,
	0x66, 0xc4, 0xa2, 0x16, 0x05, 0x3d, 0xd3, 0x6b, 0xc8, 0x5e, 0x7a, 0xa6, 0xd7, 0x74, 0xdb, 0x68,
	0xfe, 0xae, 0xc1, 0x0a, 0xa1, 0x53, 0x31, 0x14, 0x37, 0xb4, 0x82, 0xd0, 0xe9, 0xfb, 0x5e, 0x31,
	0xfe, 0x0a, 0x6a, 0x39, 0x9d, 0xd2, 0x11, 0x4b, 0x32, 0x51, 0x69, 0xbd, 0x7d, 0xd7, 0x2d, 0x67,
	0xb3, 0xe7, 0x9f, 0xd0, 0xe9, 0xa0, 0x80, 0x77, 0xf5, 0x37, 0x97, 0x1b, 0xb7, 0x48, 0x49, 0x17,
	0x35, 0xc8, 0x91, 0x13, 0xfd, 0x98, 0x9f, 0x33, 0x05, 0xe1, 0x1d, 0x30, 0x72, 0xde, 0x1e, 0xc7,
	0x14, 0xd1, 0x57, 0xd5, 0xa5, 0x88, 0x9e, 0xed, 0xd6, 0x78, 0xcc, 0xb7, 0x97, 0x1b, 0x88, 0x48,
	0x16, 0xfe, 0x06, 0xac, 0x8c, 0x32, 0x1a, 0xf3, 0x32, 0x9d, 0x65, 0x21, 0x59, 0x57, 0x92, 0x6a,
	0xf9, 0x2e, 0x51, 0x2c, 0x32, 0x13, 0x34, 0x5e, 0x21, 0xb0, 0x4a, 0x00, 0x1f, 0xc0, 0x4a, 0x46,
	0xa3, 0xe4, 0x9c, 0x0e, 0xfd, 0x09, 0xa3, 0x99, 0x68, 0x55, 0xbd, 0x7d, 0xcf, 0x95, 0xbb, 0xe4,
	0xaa, 0x5d, 0x72, 0xf7, 0x8a, 0x5d, 0x93, 0x6e, 0x7e, 0xf9, 0x6b, 0x03, 0x91, 0xba, 0x14, 0x76,
	0xb8, 0x0e, 0x3f, 0x84, 0x7a, 0x26, 0x52, 0x9f, 0xd3, 0x21, 0x4b, 0x44, 0x4b, 0xaf, 0xdc, 0xac,
	0x82, 0xbd, 0xa4, 0xf9, 0x0f, 0x02, 0xf3, 0x69, 0x12, 0x4f, 0xc2, 0x00, 0x3f, 0x82, 0x5a, 0xd1,
	0x85, 0xdc, 0x41, 0x9b, 0xda, 0x56, 0xbd, 0x7d, 0xa7, 0x1c, 0xc9, 0xd9, 0xae, 0xaa, 0xbe, 0x2a,
	0x2a, 0xfe, 0xfa, 0xda, 0x1c, 0xd5, 0x17, 0xec, 0x52, 0x45, 0x5a, 0x1d, 0xac, 0xf6, 0xfc, 0x60,
	0xd5, 0xaf, 0x6e, 0x41, 0x45, 0xa6, 0x88, 0xf8, 0x31, 0xef, 0xb9, 0x6c, 0x6d, 0xee, 0xe8, 0x42,
	0xb5, 0xb6, 0xa8, 0xe7, 0x85, 0x6e, 0x46, 0x6e, 0xfe, 0x89, 0xc0, 0xfa, 0xfe, 0x8c, 0x66, 0x17,
	0x62, 0x22, 0xcb, 0xab, 0x46, 0xff, 0xeb, 0xaa, 0x1f, 0xc3, 0xf2, 0x24, 0x9c, 0x32, 0x9a, 0xa9,
	0x22, 0x1d, 0x25, 0x28, 0x43, 0xba, 0x07, 0x82, 0xa0, 0x0c, 0x17, 0xf4, 0xc6, 0x10, 0x4c, 0x09,
	0xe0, 0x2d, 0xb0, 0xca, 0xe2, 0x17, 0xfc, 0x2b, 0xcd, 0x40, 0xfc, 0x10, 0xcc, 0xcc, 0x8f, 0x03,
	0xaa, 0x92, 0x95, 0xee, 0x08, 0x3f, 0x2d, 0x32, 0x14, 0x94, 0xe6, 0x6b, 0x1d, 0x0c, 0x71, 0x8e,
	0xef, 0x83, 0x16, 0xc6, 0x4c, 0xdc, 0x79, 0xbd, 0xfd, 0xc1, 0x9c, 0xc6, 0xed, 0xc6, 0x8c, 0x70,
	0x14, 0x3f, 0x00, 0x63, 0x32, 0x4d, 0x7c, 0x26, 0x36, 0xab, 0x72, 0xcb, 0x92, 0x76, 0xc0, 0x21,
	0x22, 0x19, 0xf8, 0x33, 0x30, 0x73, 0x96, 0xf1, 0x9d, 0x91, 0xdb, 0xb6, 0x36, 0xcf, 0x1d, 0x08,
	0x8c, 0x14, 0x1c, 0xfc, 0x08, 0xac, 0xf2, 0x8f, 0x5e, 0x2c, 0x19, 0x5f, 0xcf, 0x39, 0x81, 0xa7,
	0x60, 0x32, 0x63, 0x36, 0x76, 0x40, 0xeb, 0xc6, 0x0c, 0xaf, 0x81, 0x71, 0x42, 0x83, 0xb0, 0x68,
	0x0c, 0x91, 0x2f, 0xd8, 0x06, 0x8d, 0xc6, 0x63, 0x39, 0xc5, 0x84, 0x3f, 0x36, 0x5a, 0x60, 0x08,
	0x8f, 0xf3, 0x02, 0xb4, 0x40, 0x80, 0xa4, 0xe0, 0x73, 0x30, 0xa5, 0xd1, 0x79, 0x85, 0xb5, 0x40,
	0x61, 0x49, 0xc5, 0x1f, 0x08, 0xac, 0xd2, 0x2a, 0xfe, 0x18, 0x40, 0x10, 0x87, 0x67, 0x71, 0xf8,
	0xb2, 0x70, 0x67, 0x89, 0x93, 0xe3, 0x38, 0x7c, 0x89, 0xef, 0x41, 0x8d, 0xc6, 0x63, 0x09, 0x4a,
	0x9b, 0xcb, 0x34, 0x1e, 0x0b, 0xe8, 0x89, 0xca, 0x27, 0x3b, 0xdd, 0xb8, 0xb6, 0xcb, 0x65, 0x12,
	0x39, 0x6f, 0xaf, 0xf9, 0x32, 0x17, 0xae, 0xbe, 0x94, 0xae, 0xf4, 0xf7, 0x50, 0x72, 0x81, 0xfc,
	0x17, 0xde, 0xfe, 0xa1, 0xf2, 0x29, 0xe4, 0x9f, 0x12, 0xbc, 0x06, 0x76, 0xf7, 0xe8, 0x45, 0xa7,
	0xd7, 0xdd, 0x1b, 0xee, 0x75, 0xfb, 0x43, 0xef, 0xc7, 0xe7, 0xfb, 0xf6, 0x2d, 0x0c, 0x60, 0xbe,
	0xe8, 0x90, 0xee, 0x91, 0x67, 0x23, 0x6c, 0x81, 0x71, 0xd0, 0xfb, 0xae, 0xe3, 0xd9, 0x1a, 0x3f,
	0x1e, 0x78, 0xa4, 0x7b, 0x74, 0x68, 0xeb, 0x78, 0x15, 0x2c, 0xaf, 0xdb, 0xdf, 0x1f, 0x78, 0x9d,
	0xfe, 0x73, 0xdb, 0xd8, 0x9e, 0xa8, 0x0f, 0x9c, 0x88, 0x7a, 0x17, 0xee, 0xa8, 0xa8, 0xfd, 0x7d,
	0x8f, 0x74, 0x9f, 0xaa, 0xc0, 0xb7, 0x01, 0x64, 0xe0, 0xe1, 0xe0, 0xb8, 0x6f, 0x23, 0x6c, 0xc3,
	0x4a, 0xf1, 0x7e, 0x78, 0xdc, 0x39, 0xdc, 0xb7, 0x97, 0x78, 0x5c, 0x91, 0x4e, 0x10, 0x34, 0x2e,
	0x90, 0x29, 0x87, 0xdf, 0xf6, 0x7a, 0xb6, 0xbe, 0xbb, 0xf2, 0xe6, 0xdd, 0x3a, 0x7a, 0xfb, 0x6e,
	0x1d, 0xfd, 0xf6, 0xf7, 0x3a, 0x3a, 0x31, 0x45, 0xdd, 0x5f, 0xfc, 0x17, 0x00, 0x00, 0xff, 0xff,
	0x83, 0xd9, 0x3a, 0x3c, 0xfa, 0x08, 0x00, 0x00,
}
