// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/factable/factable.proto

package factable

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/golang/protobuf/ptypes/duration"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	protocol "go.gazette.dev/core/broker/protocol"
	go_gazette_dev_core_consumer_protocol "go.gazette.dev/core/consumer/protocol"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DimensionType int32

const (
	DimensionType_INVALID_DIM_TYPE DimensionType = 0
	DimensionType_VARINT           DimensionType = 1
	DimensionType_FLOAT            DimensionType = 3
	DimensionType_STRING           DimensionType = 4
	DimensionType_TIMESTAMP        DimensionType = 5
)

var DimensionType_name = map[int32]string{
	0: "INVALID_DIM_TYPE",
	1: "VARINT",
	3: "FLOAT",
	4: "STRING",
	5: "TIMESTAMP",
}

var DimensionType_value = map[string]int32{
	"INVALID_DIM_TYPE": 0,
	"VARINT":           1,
	"FLOAT":            3,
	"STRING":           4,
	"TIMESTAMP":        5,
}

func (x DimensionType) String() string {
	return proto.EnumName(DimensionType_name, int32(x))
}

func (DimensionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{0}
}

type MetricType int32

const (
	MetricType_INVALID_METRIC_TYPE MetricType = 0
	MetricType_VARINT_SUM          MetricType = 1
	MetricType_VARINT_GAUGE        MetricType = 2
	MetricType_FLOAT_SUM           MetricType = 3
	MetricType_STRING_HLL          MetricType = 4
)

var MetricType_name = map[int32]string{
	0: "INVALID_METRIC_TYPE",
	1: "VARINT_SUM",
	2: "VARINT_GAUGE",
	3: "FLOAT_SUM",
	4: "STRING_HLL",
}

var MetricType_value = map[string]int32{
	"INVALID_METRIC_TYPE": 0,
	"VARINT_SUM":          1,
	"VARINT_GAUGE":        2,
	"FLOAT_SUM":           3,
	"STRING_HLL":          4,
}

func (x MetricType) String() string {
	return proto.EnumName(MetricType_name, int32(x))
}

func (MetricType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{1}
}

// MappingSpec defines a Mapping of input Messages to InputRecords. In many
// cases, Relations will opt to use an identity Mapping. For events having
// de-normalized & nested event structures, Mappings provide a means to
// "unpack" into multiple normalized RelationRows. For example a "purchase"
// event having several product SKUs might map to a RelationRow{purchase, SKU}
// tuple for each purchased product.
type MappingSpec struct {
	// Short, unique name of the Mapping.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Longer, free-form description of the Mapping.
	Desc string `protobuf:"bytes,2,opt,name=desc,proto3" json:"desc,omitempty"`
	// Unique tag of the Mapping.
	Tag MapTag `protobuf:"varint,3,opt,name=tag,proto3,casttype=MapTag" json:"tag,omitempty"`
}

func (m *MappingSpec) Reset()         { *m = MappingSpec{} }
func (m *MappingSpec) String() string { return proto.CompactTextString(m) }
func (*MappingSpec) ProtoMessage()    {}
func (*MappingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{0}
}
func (m *MappingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MappingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingSpec.Merge(m, src)
}
func (m *MappingSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MappingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MappingSpec proto.InternalMessageInfo

// DimensionSpec defines a Dimension which may be extracted from a RelationRow.
type DimensionSpec struct {
	// Short, unique name of the Dimension.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Type of the Dimension. Immutable.
	Type DimensionType `protobuf:"varint,2,opt,name=type,proto3,enum=factable.DimensionType" json:"type,omitempty"`
	// Longer, free-form description of the Dimension.
	Desc string `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	// Unique tag of the dimension.
	Tag DimTag `protobuf:"varint,4,opt,name=tag,proto3,casttype=DimTag" json:"tag,omitempty"`
}

func (m *DimensionSpec) Reset()         { *m = DimensionSpec{} }
func (m *DimensionSpec) String() string { return proto.CompactTextString(m) }
func (*DimensionSpec) ProtoMessage()    {}
func (*DimensionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{1}
}
func (m *DimensionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DimensionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DimensionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DimensionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DimensionSpec.Merge(m, src)
}
func (m *DimensionSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DimensionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DimensionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DimensionSpec proto.InternalMessageInfo

// MetricSpec defines a Metric which may be derived from a specified Dimension.
type MetricSpec struct {
	// Short, unique name of the Metric.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Dimension from which the Metric is extracted.
	Dimension string `protobuf:"bytes,2,opt,name=dimension,proto3" json:"dimension,omitempty"`
	// Type of the Metric. Immutable.
	Type MetricType `protobuf:"varint,3,opt,name=type,proto3,enum=factable.MetricType" json:"type,omitempty"`
	// Longer, free-form description of the Metric.
	Desc string `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
	// Unique tag of the Metric.
	Tag MetTag `protobuf:"varint,5,opt,name=tag,proto3,casttype=MetTag" json:"tag,omitempty"`
	// Resolved DimTag of |dimension|. Immutable.
	DimTag DimTag `protobuf:"varint,6,opt,name=dim_tag,json=dimTag,proto3,casttype=DimTag" json:"dim_tag,omitempty" yaml:",omitempty"`
}

func (m *MetricSpec) Reset()         { *m = MetricSpec{} }
func (m *MetricSpec) String() string { return proto.CompactTextString(m) }
func (*MetricSpec) ProtoMessage()    {}
func (*MetricSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{2}
}
func (m *MetricSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricSpec.Merge(m, src)
}
func (m *MetricSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MetricSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MetricSpec proto.InternalMessageInfo

// RelationSpec composes a journal LabelSelector, which defines a collection of
// input events, with a mapping that transforms each event into one or more
// RelationRows.
type RelationSpec struct {
	// Short, unique name of the Relation.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// LabelSelector identifies journals which, taken together, compose the "rows" of the Relation.
	Selector protocol.LabelSelector `protobuf:"bytes,2,opt,name=selector,proto3" json:"selector"`
	// Mapping which transforms journal events into Relation rows.
	Mapping string `protobuf:"bytes,3,opt,name=mapping,proto3" json:"mapping,omitempty"`
	// Dimensions of the Relation. Dimensions may be added and removed over time,
	// but all Dimensions or derived Metrics of current MaterializedViewSpecs must
	// refer to current Dimensions of the RelationSpec.
	Dimensions []string `protobuf:"bytes,4,rep,name=dimensions,proto3" json:"dimensions,omitempty"`
	// Longer, free-form description of the Relation.
	Desc string `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
	// Unique tag of the Relation.
	Tag RelTag `protobuf:"varint,6,opt,name=tag,proto3,casttype=RelTag" json:"tag,omitempty"`
	// Resolved MapTag of |mapping|. Immutable.
	MapTag MapTag `protobuf:"varint,7,opt,name=map_tag,json=mapTag,proto3,casttype=MapTag" json:"map_tag,omitempty" yaml:",omitempty"`
	// Resolved DimTags of |dimensions|. Immutable.
	DimTags []DimTag `protobuf:"varint,8,rep,packed,name=dim_tags,json=dimTags,proto3,casttype=DimTag" json:"dim_tags,omitempty" yaml:",omitempty"`
}

func (m *RelationSpec) Reset()         { *m = RelationSpec{} }
func (m *RelationSpec) String() string { return proto.CompactTextString(m) }
func (*RelationSpec) ProtoMessage()    {}
func (*RelationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{3}
}
func (m *RelationSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelationSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelationSpec.Merge(m, src)
}
func (m *RelationSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RelationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RelationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RelationSpec proto.InternalMessageInfo

// ViewSpec defines a summarized view over a Relation, composing a subset of
// Relation dimensions with a set of derived Metrics.
type ViewSpec struct {
	// Ordered Dimensions summarized by the ViewSpec.
	Dimensions []string `protobuf:"bytes,1,rep,name=dimensions,proto3" json:"dimensions,omitempty"`
	// Ordered Metrics aggregated by the ViewSpec.
	Metrics []string `protobuf:"bytes,2,rep,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *ViewSpec) Reset()         { *m = ViewSpec{} }
func (m *ViewSpec) String() string { return proto.CompactTextString(m) }
func (*ViewSpec) ProtoMessage()    {}
func (*ViewSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{4}
}
func (m *ViewSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewSpec.Merge(m, src)
}
func (m *ViewSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ViewSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ViewSpec proto.InternalMessageInfo

type ResolvedView struct {
	// Resolved DimTags of ViewSpec Dimensions.
	DimTags []DimTag `protobuf:"varint,1,rep,packed,name=dim_tags,json=dimTags,proto3,casttype=DimTag" json:"dim_tags,omitempty"`
	// Resolved MetTags of ViewSpec Metrics.
	MetTags []MetTag `protobuf:"varint,2,rep,packed,name=met_tags,json=metTags,proto3,casttype=MetTag" json:"met_tags,omitempty"`
}

func (m *ResolvedView) Reset()         { *m = ResolvedView{} }
func (m *ResolvedView) String() string { return proto.CompactTextString(m) }
func (*ResolvedView) ProtoMessage()    {}
func (*ResolvedView) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{5}
}
func (m *ResolvedView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolvedView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolvedView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolvedView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolvedView.Merge(m, src)
}
func (m *ResolvedView) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ResolvedView) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolvedView.DiscardUnknown(m)
}

var xxx_messageInfo_ResolvedView proto.InternalMessageInfo

// ReservedMVTagSpec defines MVTags that cannot be used in this schema. This
// can be used to reserve tags for future materialized views or to tombstone
// deleted materialized views. Re-using materialized view tags requires careful
// consideration of previously used delta journals and shard recovery logs
// because the tag is an input for generating shard IDs in `factctl sync`.
type ReservedMVTagSpec struct {
	// Reserved tag in the same space as MaterializedView.
	Tag MVTag `protobuf:"varint,1,opt,name=tag,proto3,casttype=MVTag" json:"tag,omitempty"`
	// Longer, free-form description of the reserved MVTag.
	Desc string `protobuf:"bytes,2,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *ReservedMVTagSpec) Reset()         { *m = ReservedMVTagSpec{} }
func (m *ReservedMVTagSpec) String() string { return proto.CompactTextString(m) }
func (*ReservedMVTagSpec) ProtoMessage()    {}
func (*ReservedMVTagSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{6}
}
func (m *ReservedMVTagSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReservedMVTagSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReservedMVTagSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReservedMVTagSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReservedMVTagSpec.Merge(m, src)
}
func (m *ReservedMVTagSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ReservedMVTagSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ReservedMVTagSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ReservedMVTagSpec proto.InternalMessageInfo

// MaterializedViewSpec defines a materialization of a ViewSpec. Its Metrics
// are continuously aggregated as RelationRows are processed, and the total
// storage commitment is limited to the cardinality of the View Dimensions.
type MaterializedViewSpec struct {
	// Short, unique name of the MaterializedView.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Relation which this view materializes.
	Relation string `protobuf:"bytes,2,opt,name=relation,proto3" json:"relation,omitempty"`
	// View materialized by the MaterializedView.
	View ViewSpec `protobuf:"bytes,3,opt,name=view,proto3" json:"view"`
	// Longer, free-form description of the MaterializedView.
	Desc      string                          `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
	Retention *MaterializedViewSpec_Retention `protobuf:"bytes,5,opt,name=retention,proto3" json:"retention,omitempty"`
	// Unique tag of the MaterializedView.
	Tag MVTag `protobuf:"varint,6,opt,name=tag,proto3,casttype=MVTag" json:"tag,omitempty"`
	// Resolved RelTag. Immutable.
	RelTag RelTag `protobuf:"varint,7,opt,name=rel_tag,json=relTag,proto3,casttype=RelTag" json:"rel_tag,omitempty" yaml:",omitempty"`
	// Resolution of the View. Immutable.
	ResolvedView ResolvedView `protobuf:"bytes,8,opt,name=resolved_view,json=resolvedView,proto3" json:"resolved_view" yaml:",omitempty"`
}

func (m *MaterializedViewSpec) Reset()         { *m = MaterializedViewSpec{} }
func (m *MaterializedViewSpec) String() string { return proto.CompactTextString(m) }
func (*MaterializedViewSpec) ProtoMessage()    {}
func (*MaterializedViewSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{7}
}
func (m *MaterializedViewSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterializedViewSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaterializedViewSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaterializedViewSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterializedViewSpec.Merge(m, src)
}
func (m *MaterializedViewSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaterializedViewSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterializedViewSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MaterializedViewSpec proto.InternalMessageInfo

// Optional retention of MaterializedView rows.
type MaterializedViewSpec_Retention struct {
	// Duration after which a row is eligible for removal.
	RemoveAfter time.Duration `protobuf:"bytes,1,opt,name=remove_after,json=removeAfter,proto3,stdduration" json:"remove_after"`
	// Dimension, which must be part of the MaterializedView and of type
	// Timestamp, to which |remove_after| is added to determine the effective
	// removal horizon.
	RelativeTo string `protobuf:"bytes,2,opt,name=relative_to,json=relativeTo,proto3" json:"relative_to,omitempty"`
	// Resolved DimTag of |relative_to|.
	RelativeToTag DimTag `protobuf:"varint,3,opt,name=relative_to_tag,json=relativeToTag,proto3,casttype=DimTag" json:"relative_to_tag,omitempty" yaml:",omitempty"`
}

func (m *MaterializedViewSpec_Retention) Reset()         { *m = MaterializedViewSpec_Retention{} }
func (m *MaterializedViewSpec_Retention) String() string { return proto.CompactTextString(m) }
func (*MaterializedViewSpec_Retention) ProtoMessage()    {}
func (*MaterializedViewSpec_Retention) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{7, 0}
}
func (m *MaterializedViewSpec_Retention) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterializedViewSpec_Retention) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaterializedViewSpec_Retention.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaterializedViewSpec_Retention) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterializedViewSpec_Retention.Merge(m, src)
}
func (m *MaterializedViewSpec_Retention) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaterializedViewSpec_Retention) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterializedViewSpec_Retention.DiscardUnknown(m)
}

var xxx_messageInfo_MaterializedViewSpec_Retention proto.InternalMessageInfo

// QuerySpec describes a result which should be computed from a Relation.
// In particular it defines the "shape" (in Dimensions and Metrics) of the
// desired result, and any filters which should be applied.
type QuerySpec struct {
	// MaterializedView to query.
	MaterializedView string `protobuf:"bytes,2,opt,name=materialized_view,json=materializedView,proto3" json:"materialized_view,omitempty"`
	// View of the Query result.
	//
	// Dimensions of the Relation which should be grouped over and returned with
	// the Query result set. Other Dimensions included in the MaterializedView but
	// not included in the Query Shape are aggregated across.
	//
	// Where possible, use a strict ordered prefix of underlying MaterializedView
	// Dimensions. This is much more efficient to evaluate, as grouping can
	// utilize the natural index order, and no further recombining or sorting is
	// required. When using a prefix, the Query result set is incrementally
	// streamed as it is evaluated, and even extremely large result sets can be
	// queried efficiently.
	//
	// If Dimensions are not a strict prefix, the Query evaluator must perform
	// recombination and sorting steps, and results will be sent only after
	// all underlying view rows have been read. Implementations may also limit
	// the size of the result sets they will buffer, returning an error for
	// Queries which exceed it.
	View    ViewSpec           `protobuf:"bytes,3,opt,name=view,proto3" json:"view"`
	Filters []QuerySpec_Filter `protobuf:"bytes,4,rep,name=filters,proto3" json:"filters"`
}

func (m *QuerySpec) Reset()         { *m = QuerySpec{} }
func (m *QuerySpec) String() string { return proto.CompactTextString(m) }
func (*QuerySpec) ProtoMessage()    {}
func (*QuerySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{8}
}
func (m *QuerySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpec.Merge(m, src)
}
func (m *QuerySpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *QuerySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpec.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpec proto.InternalMessageInfo

// A Filter is a sequence of ordered non-overlapping ranges for a Dimension.
// Filters may be applied to any subset of MaterializedView Dimensions,
// including those not present in the Query View.
type QuerySpec_Filter struct {
	// Dimension to which the Filter is applied.
	Dimension string                    `protobuf:"bytes,1,opt,name=dimension,proto3" json:"dimension,omitempty"`
	Ints      []QuerySpec_Filter_Int    `protobuf:"bytes,2,rep,name=ints,proto3" json:"ints"`
	Floats    []QuerySpec_Filter_Float  `protobuf:"bytes,3,rep,name=floats,proto3" json:"floats"`
	Strings   []QuerySpec_Filter_String `protobuf:"bytes,4,rep,name=strings,proto3" json:"strings"`
	Times     []QuerySpec_Filter_Time   `protobuf:"bytes,5,rep,name=times,proto3" json:"times"`
}

func (m *QuerySpec_Filter) Reset()         { *m = QuerySpec_Filter{} }
func (m *QuerySpec_Filter) String() string { return proto.CompactTextString(m) }
func (*QuerySpec_Filter) ProtoMessage()    {}
func (*QuerySpec_Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{8, 0}
}
func (m *QuerySpec_Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpec_Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpec_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySpec_Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpec_Filter.Merge(m, src)
}
func (m *QuerySpec_Filter) XXX_Size() int {
	return m.ProtoSize()
}
func (m *QuerySpec_Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpec_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpec_Filter proto.InternalMessageInfo

type QuerySpec_Filter_Int struct {
	Begin int64 `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End   int64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *QuerySpec_Filter_Int) Reset()         { *m = QuerySpec_Filter_Int{} }
func (m *QuerySpec_Filter_Int) String() string { return proto.CompactTextString(m) }
func (*QuerySpec_Filter_Int) ProtoMessage()    {}
func (*QuerySpec_Filter_Int) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{8, 0, 0}
}
func (m *QuerySpec_Filter_Int) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpec_Filter_Int) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpec_Filter_Int.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySpec_Filter_Int) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpec_Filter_Int.Merge(m, src)
}
func (m *QuerySpec_Filter_Int) XXX_Size() int {
	return m.ProtoSize()
}
func (m *QuerySpec_Filter_Int) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpec_Filter_Int.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpec_Filter_Int proto.InternalMessageInfo

type QuerySpec_Filter_Float struct {
	Begin float64 `protobuf:"fixed64,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End   float64 `protobuf:"fixed64,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *QuerySpec_Filter_Float) Reset()         { *m = QuerySpec_Filter_Float{} }
func (m *QuerySpec_Filter_Float) String() string { return proto.CompactTextString(m) }
func (*QuerySpec_Filter_Float) ProtoMessage()    {}
func (*QuerySpec_Filter_Float) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{8, 0, 1}
}
func (m *QuerySpec_Filter_Float) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpec_Filter_Float) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpec_Filter_Float.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySpec_Filter_Float) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpec_Filter_Float.Merge(m, src)
}
func (m *QuerySpec_Filter_Float) XXX_Size() int {
	return m.ProtoSize()
}
func (m *QuerySpec_Filter_Float) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpec_Filter_Float.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpec_Filter_Float proto.InternalMessageInfo

type QuerySpec_Filter_String struct {
	Begin string `protobuf:"bytes,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End   string `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *QuerySpec_Filter_String) Reset()         { *m = QuerySpec_Filter_String{} }
func (m *QuerySpec_Filter_String) String() string { return proto.CompactTextString(m) }
func (*QuerySpec_Filter_String) ProtoMessage()    {}
func (*QuerySpec_Filter_String) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{8, 0, 2}
}
func (m *QuerySpec_Filter_String) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpec_Filter_String) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpec_Filter_String.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySpec_Filter_String) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpec_Filter_String.Merge(m, src)
}
func (m *QuerySpec_Filter_String) XXX_Size() int {
	return m.ProtoSize()
}
func (m *QuerySpec_Filter_String) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpec_Filter_String.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpec_Filter_String proto.InternalMessageInfo

type QuerySpec_Filter_Time struct {
	Begin         time.Time     `protobuf:"bytes,1,opt,name=begin,proto3,stdtime" json:"begin"`
	End           time.Time     `protobuf:"bytes,2,opt,name=end,proto3,stdtime" json:"end"`
	RelativeBegin time.Duration `protobuf:"bytes,3,opt,name=relative_begin,json=relativeBegin,proto3,stdduration" json:"relative_begin"`
	RelativeEnd   time.Duration `protobuf:"bytes,4,opt,name=relative_end,json=relativeEnd,proto3,stdduration" json:"relative_end"`
}

func (m *QuerySpec_Filter_Time) Reset()         { *m = QuerySpec_Filter_Time{} }
func (m *QuerySpec_Filter_Time) String() string { return proto.CompactTextString(m) }
func (*QuerySpec_Filter_Time) ProtoMessage()    {}
func (*QuerySpec_Filter_Time) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{8, 0, 3}
}
func (m *QuerySpec_Filter_Time) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpec_Filter_Time) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpec_Filter_Time.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySpec_Filter_Time) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpec_Filter_Time.Merge(m, src)
}
func (m *QuerySpec_Filter_Time) XXX_Size() int {
	return m.ProtoSize()
}
func (m *QuerySpec_Filter_Time) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpec_Filter_Time.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpec_Filter_Time proto.InternalMessageInfo

type ResolvedQuery struct {
	// Tag of the MaterializedViewSpec to be queried.
	MvTag MVTag `protobuf:"varint,1,opt,name=mv_tag,json=mvTag,proto3,casttype=MVTag" json:"mv_tag,omitempty"`
	// Shape of the query result.
	View    ResolvedView           `protobuf:"bytes,2,opt,name=view,proto3" json:"view"`
	Filters []ResolvedQuery_Filter `protobuf:"bytes,3,rep,name=filters,proto3" json:"filters"`
}

func (m *ResolvedQuery) Reset()         { *m = ResolvedQuery{} }
func (m *ResolvedQuery) String() string { return proto.CompactTextString(m) }
func (*ResolvedQuery) ProtoMessage()    {}
func (*ResolvedQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{9}
}
func (m *ResolvedQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolvedQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolvedQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolvedQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolvedQuery.Merge(m, src)
}
func (m *ResolvedQuery) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ResolvedQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolvedQuery.DiscardUnknown(m)
}

var xxx_messageInfo_ResolvedQuery proto.InternalMessageInfo

// Flattened filtered ranges over each view dimension.
type ResolvedQuery_Filter struct {
	// Dimension to which the Filter is applied.
	DimTag DimTag                       `protobuf:"varint,1,opt,name=dim_tag,json=dimTag,proto3,casttype=DimTag" json:"dim_tag,omitempty"`
	Ranges []ResolvedQuery_Filter_Range `protobuf:"bytes,2,rep,name=ranges,proto3" json:"ranges"`
}

func (m *ResolvedQuery_Filter) Reset()         { *m = ResolvedQuery_Filter{} }
func (m *ResolvedQuery_Filter) String() string { return proto.CompactTextString(m) }
func (*ResolvedQuery_Filter) ProtoMessage()    {}
func (*ResolvedQuery_Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{9, 0}
}
func (m *ResolvedQuery_Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolvedQuery_Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolvedQuery_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolvedQuery_Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolvedQuery_Filter.Merge(m, src)
}
func (m *ResolvedQuery_Filter) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ResolvedQuery_Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolvedQuery_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_ResolvedQuery_Filter proto.InternalMessageInfo

// Flattened allowed byte ranges of the Dimension.
type ResolvedQuery_Filter_Range struct {
	Begin []byte `protobuf:"bytes,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End   []byte `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *ResolvedQuery_Filter_Range) Reset()         { *m = ResolvedQuery_Filter_Range{} }
func (m *ResolvedQuery_Filter_Range) String() string { return proto.CompactTextString(m) }
func (*ResolvedQuery_Filter_Range) ProtoMessage()    {}
func (*ResolvedQuery_Filter_Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{9, 0, 0}
}
func (m *ResolvedQuery_Filter_Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolvedQuery_Filter_Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolvedQuery_Filter_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolvedQuery_Filter_Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolvedQuery_Filter_Range.Merge(m, src)
}
func (m *ResolvedQuery_Filter_Range) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ResolvedQuery_Filter_Range) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolvedQuery_Filter_Range.DiscardUnknown(m)
}

var xxx_messageInfo_ResolvedQuery_Filter_Range proto.InternalMessageInfo

type ExecuteQueryRequest struct {
	// Header attached by a proxy-ing peer. Not directly set by clients.
	Header *protocol.Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// Shard to query. Set iff |header| is also set
	// TODO (chris): if this is go.gazette.dev/core/consumer.ShardID instead of a string
	// the .pb.go file is not valid.
	Shard go_gazette_dev_core_consumer_protocol.ShardID `protobuf:"bytes,2,opt,name=shard,proto3,casttype=go.gazette.dev/core/consumer/protocol.ShardID" json:"shard,omitempty"`
	// Query specification.
	Query ResolvedQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query"`
}

func (m *ExecuteQueryRequest) Reset()         { *m = ExecuteQueryRequest{} }
func (m *ExecuteQueryRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteQueryRequest) ProtoMessage()    {}
func (*ExecuteQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{10}
}
func (m *ExecuteQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteQueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteQueryRequest.Merge(m, src)
}
func (m *ExecuteQueryRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteQueryRequest proto.InternalMessageInfo

type QueryResponse struct {
	// Response header. Set on the first QueryResponse only.
	Header *protocol.Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// Encoded table rows.
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *QueryResponse) Reset()         { *m = QueryResponse{} }
func (m *QueryResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResponse) ProtoMessage()    {}
func (*QueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{11}
}
func (m *QueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResponse.Merge(m, src)
}
func (m *QueryResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *QueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResponse proto.InternalMessageInfo

// SchemaSpec defines a set of Relations and their Mappings, Dimensions, Metrics,
// and MaterializedViews. The complete Schema must be referentially consistent:
// any Mapping, Dimension or Metric used in a Relation or MaterializedView must
// be defined. Similarly, Dimensions referenced from Metrics must be defined,
// and of the proper associated type.
type SchemaSpec struct {
	Mappings         []MappingSpec          `protobuf:"bytes,1,rep,name=mappings,proto3" json:"mappings"`
	Dimensions       []DimensionSpec        `protobuf:"bytes,2,rep,name=dimensions,proto3" json:"dimensions"`
	Metrics          []MetricSpec           `protobuf:"bytes,3,rep,name=metrics,proto3" json:"metrics"`
	Relations        []RelationSpec         `protobuf:"bytes,4,rep,name=relations,proto3" json:"relations"`
	Views            []MaterializedViewSpec `protobuf:"bytes,5,rep,name=views,proto3" json:"views"`
	ReservedViewTags []ReservedMVTagSpec    `protobuf:"bytes,6,rep,name=reserved_view_tags,json=reservedViewTags,proto3" json:"reserved_view_tags"`
}

func (m *SchemaSpec) Reset()         { *m = SchemaSpec{} }
func (m *SchemaSpec) String() string { return proto.CompactTextString(m) }
func (*SchemaSpec) ProtoMessage()    {}
func (*SchemaSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{12}
}
func (m *SchemaSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaSpec.Merge(m, src)
}
func (m *SchemaSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SchemaSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaSpec proto.InternalMessageInfo

// GetSchemaResponse is the response of the GetSchema RPC.
type GetSchemaResponse struct {
	// Name of this Factable release instance.
	Instance string `protobuf:"bytes,3,opt,name=instance,proto3" json:"instance,omitempty"`
	// ModRevision of the current SchemaSpec
	ModRevision int64 `protobuf:"varint,1,opt,name=mod_revision,json=modRevision,proto3" json:"mod_revision,omitempty"`
	// Current value of the SchemaSpec. Zero-valued if |mod_revision| is zero.
	Spec SchemaSpec `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec"`
	// LabelSelector over Extractor output / VTable input "delta" partitions.
	DeltaPartitions protocol.LabelSelector `protobuf:"bytes,4,opt,name=delta_partitions,json=deltaPartitions,proto3" json:"delta_partitions"`
}

func (m *GetSchemaResponse) Reset()         { *m = GetSchemaResponse{} }
func (m *GetSchemaResponse) String() string { return proto.CompactTextString(m) }
func (*GetSchemaResponse) ProtoMessage()    {}
func (*GetSchemaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{13}
}
func (m *GetSchemaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSchemaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSchemaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSchemaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSchemaResponse.Merge(m, src)
}
func (m *GetSchemaResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetSchemaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSchemaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSchemaResponse proto.InternalMessageInfo

// UpdateSchemaRequest is the request of the UpdateSchema RPC.
type UpdateSchemaRequest struct {
	// Expected Name of the Factable release instance.
	ExpectInstance string `protobuf:"bytes,1,opt,name=expect_instance,json=expectInstance,proto3" json:"expect_instance,omitempty"`
	// Expected ModRevision of the current SchemaSpec. Zero if the SchemaSpec
	// is being created for the first time.
	ExpectModRevision int64 `protobuf:"varint,2,opt,name=expect_mod_revision,json=expectModRevision,proto3" json:"expect_mod_revision,omitempty"`
	// Updated SchemaSpec to apply.
	Update SchemaSpec `protobuf:"bytes,3,opt,name=update,proto3" json:"update"`
}

func (m *UpdateSchemaRequest) Reset()         { *m = UpdateSchemaRequest{} }
func (m *UpdateSchemaRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateSchemaRequest) ProtoMessage()    {}
func (*UpdateSchemaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8cf26f69bbb4fd9d, []int{14}
}
func (m *UpdateSchemaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSchemaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateSchemaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateSchemaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSchemaRequest.Merge(m, src)
}
func (m *UpdateSchemaRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UpdateSchemaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSchemaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSchemaRequest proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("factable.DimensionType", DimensionType_name, DimensionType_value)
	proto.RegisterEnum("factable.MetricType", MetricType_name, MetricType_value)
	proto.RegisterType((*MappingSpec)(nil), "factable.MappingSpec")
	proto.RegisterType((*DimensionSpec)(nil), "factable.DimensionSpec")
	proto.RegisterType((*MetricSpec)(nil), "factable.MetricSpec")
	proto.RegisterType((*RelationSpec)(nil), "factable.RelationSpec")
	proto.RegisterType((*ViewSpec)(nil), "factable.ViewSpec")
	proto.RegisterType((*ResolvedView)(nil), "factable.ResolvedView")
	proto.RegisterType((*ReservedMVTagSpec)(nil), "factable.ReservedMVTagSpec")
	proto.RegisterType((*MaterializedViewSpec)(nil), "factable.MaterializedViewSpec")
	proto.RegisterType((*MaterializedViewSpec_Retention)(nil), "factable.MaterializedViewSpec.Retention")
	proto.RegisterType((*QuerySpec)(nil), "factable.QuerySpec")
	proto.RegisterType((*QuerySpec_Filter)(nil), "factable.QuerySpec.Filter")
	proto.RegisterType((*QuerySpec_Filter_Int)(nil), "factable.QuerySpec.Filter.Int")
	proto.RegisterType((*QuerySpec_Filter_Float)(nil), "factable.QuerySpec.Filter.Float")
	proto.RegisterType((*QuerySpec_Filter_String)(nil), "factable.QuerySpec.Filter.String")
	proto.RegisterType((*QuerySpec_Filter_Time)(nil), "factable.QuerySpec.Filter.Time")
	proto.RegisterType((*ResolvedQuery)(nil), "factable.ResolvedQuery")
	proto.RegisterType((*ResolvedQuery_Filter)(nil), "factable.ResolvedQuery.Filter")
	proto.RegisterType((*ResolvedQuery_Filter_Range)(nil), "factable.ResolvedQuery.Filter.Range")
	proto.RegisterType((*ExecuteQueryRequest)(nil), "factable.ExecuteQueryRequest")
	proto.RegisterType((*QueryResponse)(nil), "factable.QueryResponse")
	proto.RegisterType((*SchemaSpec)(nil), "factable.SchemaSpec")
	proto.RegisterType((*GetSchemaResponse)(nil), "factable.GetSchemaResponse")
	proto.RegisterType((*UpdateSchemaRequest)(nil), "factable.UpdateSchemaRequest")
}

func init() { proto.RegisterFile("pkg/factable/factable.proto", fileDescriptor_8cf26f69bbb4fd9d) }

var fileDescriptor_8cf26f69bbb4fd9d = []byte{
	// 1714 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0xbb, 0x73, 0x1b, 0x5d,
	0x15, 0xf7, 0x6a, 0x57, 0x2b, 0xe9, 0x48, 0x76, 0xd6, 0xd7, 0xe6, 0xb3, 0x3e, 0x25, 0x48, 0xfe,
	0x04, 0x0c, 0x9e, 0xef, 0x21, 0x07, 0x85, 0x81, 0x60, 0x20, 0x83, 0x85, 0x64, 0x5b, 0x19, 0x2b,
	0x09, 0x2b, 0xc5, 0x0c, 0x95, 0x66, 0x2d, 0x5d, 0x2b, 0x3b, 0xd1, 0x3e, 0xb2, 0x7b, 0xad, 0xc4,
	0x29, 0xa1, 0x87, 0xd0, 0x51, 0x66, 0xf2, 0x7f, 0x64, 0x52, 0xd0, 0xb8, 0xa0, 0x48, 0x41, 0x41,
	0x65, 0x86, 0xb8, 0xa7, 0xa0, 0x4c, 0xc5, 0xdc, 0xd7, 0xee, 0xca, 0x96, 0x1c, 0xa7, 0x91, 0xee,
	0xe3, 0xfc, 0xce, 0xfb, 0x9c, 0x7b, 0x16, 0x6e, 0xfa, 0x4f, 0x47, 0x9b, 0x47, 0xd6, 0x80, 0x58,
	0x87, 0x63, 0x1c, 0x2d, 0x6a, 0x7e, 0xe0, 0x11, 0x0f, 0x65, 0xe5, 0xbe, 0xb4, 0x3a, 0xf2, 0x46,
	0x1e, 0x3b, 0xdc, 0xa4, 0x2b, 0x7e, 0x5f, 0x2a, 0x1f, 0x06, 0xde, 0x53, 0x1c, 0x6c, 0xb2, 0xdd,
	0xc0, 0x1b, 0x47, 0x0b, 0x79, 0xef, 0x93, 0x13, 0x1f, 0x87, 0x9b, 0xc3, 0xe3, 0xc0, 0x22, 0xb6,
	0xe7, 0x46, 0x0b, 0x71, 0xbf, 0x2e, 0xee, 0x89, 0xed, 0xe0, 0x90, 0x58, 0x8e, 0x1f, 0xaf, 0x04,
	0x45, 0x51, 0x50, 0x60, 0xc7, 0x27, 0x27, 0xfc, 0x97, 0xdf, 0x54, 0xbb, 0x90, 0xef, 0x58, 0xbe,
	0x6f, 0xbb, 0xa3, 0xae, 0x8f, 0x07, 0x08, 0x81, 0xe6, 0x5a, 0x0e, 0x2e, 0x2a, 0xeb, 0xca, 0x46,
	0xce, 0x64, 0x6b, 0x7a, 0x36, 0xc4, 0xe1, 0xa0, 0x98, 0xe2, 0x67, 0x74, 0x8d, 0x6e, 0x81, 0x4a,
	0xac, 0x51, 0x51, 0x5d, 0x57, 0x36, 0xb4, 0x06, 0x7c, 0x3c, 0xab, 0xe8, 0x1d, 0xcb, 0xef, 0x59,
	0x23, 0x93, 0x1e, 0x57, 0xff, 0xa8, 0xc0, 0x62, 0xd3, 0x76, 0xb0, 0x1b, 0xda, 0x9e, 0x3b, 0x97,
	0xef, 0x37, 0xa0, 0x51, 0xad, 0x18, 0xdf, 0xa5, 0xfa, 0x5a, 0x2d, 0xf2, 0x5a, 0x04, 0xed, 0x9d,
	0xf8, 0xd8, 0x64, 0x44, 0x91, 0x12, 0xea, 0x65, 0x25, 0xb4, 0x58, 0x89, 0xa6, 0xed, 0x44, 0x4a,
	0xfc, 0x53, 0x01, 0xe8, 0x60, 0x12, 0xd8, 0x83, 0xb9, 0x1a, 0xdc, 0x82, 0xdc, 0x50, 0xca, 0x12,
	0xe6, 0xc5, 0x07, 0x68, 0x43, 0xe8, 0xa7, 0x32, 0xfd, 0x56, 0x63, 0xfd, 0x38, 0xd7, 0x19, 0xca,
	0x69, 0x97, 0x95, 0x4b, 0x27, 0x3c, 0x84, 0x89, 0x54, 0x0e, 0xdd, 0x85, 0xcc, 0xd0, 0x76, 0xfa,
	0x94, 0x42, 0x67, 0x14, 0x95, 0xff, 0x9d, 0x55, 0x96, 0x4f, 0x2c, 0x67, 0xbc, 0x55, 0xfd, 0xd6,
	0x73, 0x6c, 0xc2, 0x62, 0x54, 0x4d, 0xd8, 0xa4, 0x0f, 0xd9, 0x7f, 0xf5, 0x5d, 0x0a, 0x0a, 0x26,
	0x1e, 0xb3, 0xf8, 0xcf, 0x35, 0xec, 0x17, 0x90, 0x0d, 0xf1, 0x18, 0x0f, 0x88, 0x17, 0x30, 0xbb,
	0xf2, 0xf5, 0xb5, 0x5a, 0x94, 0x54, 0xfb, 0xd6, 0x21, 0x1e, 0x77, 0xc5, 0x75, 0x43, 0x3b, 0x3d,
	0xab, 0x2c, 0x98, 0x11, 0x39, 0x2a, 0x42, 0xc6, 0xe1, 0x09, 0x21, 0x7c, 0x2d, 0xb7, 0xa8, 0x0c,
	0x10, 0x39, 0x27, 0x2c, 0x6a, 0xeb, 0xea, 0x46, 0xce, 0x4c, 0x9c, 0x44, 0x5e, 0x48, 0x5f, 0xf6,
	0x82, 0x1e, 0x7b, 0xc1, 0xc4, 0xe3, 0xa4, 0x17, 0x1c, 0xcb, 0x67, 0x5e, 0xc8, 0x7c, 0xc2, 0x0b,
	0x22, 0xbd, 0x74, 0x87, 0xfd, 0xa3, 0x2d, 0xc8, 0x0a, 0xff, 0x85, 0xc5, 0xec, 0xba, 0x7a, 0x1d,
	0x07, 0x66, 0xb8, 0x03, 0xc3, 0x6a, 0x13, 0xb2, 0x07, 0x36, 0x7e, 0xce, 0x9c, 0x37, 0x6d, 0x93,
	0x72, 0xc9, 0x26, 0xea, 0x0d, 0x16, 0xed, 0xb0, 0x98, 0x62, 0x97, 0x72, 0x5b, 0x3d, 0xa4, 0x61,
	0x08, 0xbd, 0xf1, 0x04, 0x0f, 0x29, 0x37, 0xf4, 0xa3, 0x84, 0x46, 0x0a, 0xd3, 0x08, 0x66, 0x08,
	0xa7, 0x64, 0x0e, 0x26, 0x9c, 0x2c, 0x15, 0x93, 0x89, 0xdc, 0xa0, 0xdc, 0x29, 0xd9, 0x96, 0xf6,
	0xfa, 0x75, 0x45, 0xa9, 0x36, 0x61, 0xd9, 0xc4, 0x21, 0x0e, 0x26, 0x78, 0xd8, 0x39, 0xe8, 0x59,
	0xbc, 0x44, 0x6f, 0x72, 0x97, 0x2a, 0xcc, 0x61, 0xb9, 0x8f, 0x67, 0x95, 0x34, 0xbb, 0xe3, 0x1e,
	0x9d, 0x51, 0xab, 0xd5, 0x77, 0x1a, 0xac, 0x76, 0x2c, 0x82, 0x03, 0xdb, 0x1a, 0xdb, 0x2f, 0xb9,
	0xba, 0x73, 0x33, 0xa7, 0x04, 0xd9, 0x40, 0x64, 0x97, 0x60, 0x12, 0xed, 0xd1, 0xb7, 0xa0, 0x4d,
	0x6c, 0xfc, 0x9c, 0xe5, 0x45, 0xbe, 0x8e, 0xe2, 0x82, 0x90, 0x1c, 0x45, 0x32, 0x31, 0xaa, 0x99,
	0x45, 0xb1, 0x03, 0xb9, 0x00, 0x13, 0xec, 0x32, 0xf6, 0x69, 0xc6, 0x66, 0x23, 0x51, 0x57, 0x33,
	0x94, 0xac, 0x99, 0x92, 0xde, 0x8c, 0xa1, 0xd2, 0x07, 0xfa, 0x4c, 0x1f, 0xdc, 0x85, 0x4c, 0x80,
	0xc7, 0xd7, 0xca, 0x2a, 0x91, 0x8c, 0x7a, 0xc0, 0xfe, 0xd1, 0x01, 0x2c, 0x06, 0x22, 0xa6, 0x7d,
	0x66, 0x69, 0x96, 0xa9, 0xf8, 0x45, 0xac, 0x62, 0x32, 0xe4, 0x8d, 0x2f, 0xa9, 0xb5, 0x33, 0x79,
	0x9b, 0x85, 0x20, 0x41, 0x58, 0x7a, 0xab, 0x40, 0x2e, 0xb2, 0x03, 0xed, 0x40, 0x21, 0xc0, 0x8e,
	0x37, 0xc1, 0x7d, 0xeb, 0x88, 0xe0, 0x80, 0xb9, 0x3f, 0x5f, 0xff, 0xb2, 0x36, 0xf2, 0xbc, 0x91,
	0x7c, 0x33, 0x0e, 0x8f, 0x8f, 0x6a, 0x4d, 0xd1, 0xe5, 0x1b, 0x59, 0x2a, 0xe7, 0x6f, 0xff, 0xae,
	0x28, 0x66, 0x9e, 0x03, 0xb7, 0x29, 0x0e, 0x55, 0x20, 0xcf, 0x43, 0x33, 0xc1, 0x7d, 0xe2, 0x89,
	0x68, 0x81, 0x3c, 0xea, 0x79, 0x68, 0x17, 0x6e, 0x24, 0x08, 0xfa, 0x71, 0xc3, 0xfe, 0x64, 0xad,
	0x2c, 0xc6, 0x5c, 0x68, 0xcf, 0xf9, 0xaf, 0x0e, 0xb9, 0xdf, 0x1d, 0xe3, 0xe0, 0x84, 0xa5, 0xcd,
	0x37, 0xb0, 0xec, 0x24, 0x22, 0xc5, 0x3d, 0xc5, 0xa5, 0x1b, 0xce, 0x85, 0x10, 0x7e, 0x66, 0xce,
	0x6c, 0x41, 0xe6, 0xc8, 0x1e, 0x13, 0x1c, 0xf0, 0xfe, 0x92, 0xaf, 0x97, 0x62, 0x40, 0xa4, 0x40,
	0x6d, 0x87, 0x91, 0x08, 0xa0, 0x04, 0x94, 0xfe, 0x9e, 0x06, 0x9d, 0xdf, 0x4c, 0xf7, 0x75, 0xe5,
	0x62, 0x5f, 0xbf, 0x0b, 0x9a, 0xed, 0x12, 0x5e, 0x7e, 0xf9, 0x7a, 0x79, 0xbe, 0x84, 0x5a, 0xdb,
	0x25, 0x52, 0x3d, 0x8a, 0x40, 0xf7, 0x40, 0x3f, 0x1a, 0x7b, 0x16, 0x09, 0x8b, 0x2a, 0xc3, 0xae,
	0x5f, 0x81, 0xdd, 0xa1, 0x84, 0x02, 0x2d, 0x50, 0x68, 0x1b, 0x32, 0x21, 0x09, 0x6c, 0x77, 0x24,
	0xcd, 0xfb, 0xea, 0x0a, 0x06, 0x5d, 0x46, 0x29, 0xad, 0x14, 0x38, 0xf4, 0x4b, 0x48, 0xb3, 0xc7,
	0xbd, 0x98, 0x66, 0x0c, 0x2a, 0x57, 0x30, 0xe8, 0xd9, 0x0e, 0x16, 0x70, 0x8e, 0x29, 0x7d, 0x07,
	0x6a, 0xdb, 0x25, 0x68, 0x15, 0xd2, 0x87, 0x78, 0x64, 0x73, 0xd7, 0xa8, 0x26, 0xdf, 0x20, 0x03,
	0x54, 0xec, 0x0e, 0x59, 0x20, 0x55, 0x93, 0x2e, 0x4b, 0x9b, 0x90, 0x66, 0x56, 0x4c, 0x03, 0x94,
	0x19, 0x00, 0x85, 0x03, 0x6e, 0x83, 0xce, 0xb5, 0x9e, 0x46, 0xe4, 0x66, 0x20, 0x72, 0x1c, 0xf1,
	0xe7, 0x14, 0x68, 0x54, 0x4f, 0xb4, 0x95, 0x04, 0xd0, 0xb8, 0x5f, 0xac, 0x86, 0x9e, 0x1c, 0x69,
	0x78, 0x39, 0xbc, 0xa2, 0xe5, 0x20, 0xd8, 0xfe, 0x2c, 0x66, 0x7b, 0x5d, 0x24, 0x05, 0xa0, 0xfb,
	0xb0, 0x14, 0xd5, 0x07, 0x17, 0xae, 0x5e, 0xbf, 0x14, 0xa3, 0x12, 0x69, 0x30, 0x1d, 0x58, 0x51,
	0x0b, 0x5e, 0x54, 0x19, 0xed, 0xb3, 0x8a, 0x9a, 0x03, 0x5b, 0xee, 0xf0, 0xbe, 0x96, 0x55, 0x8c,
	0x54, 0xf5, 0x34, 0x05, 0x8b, 0xb2, 0xd5, 0xb0, 0xb8, 0xa2, 0x75, 0xd0, 0x9d, 0x49, 0x7f, 0x66,
	0xe3, 0x4f, 0x3b, 0x13, 0xda, 0xbc, 0x6e, 0x8b, 0x4a, 0x4b, 0x5d, 0xd9, 0xb3, 0x92, 0xd5, 0x76,
	0x2f, 0xae, 0x36, 0xf5, 0x62, 0x2d, 0x4c, 0x49, 0x9f, 0x53, 0x71, 0x6f, 0x94, 0xa8, 0xe2, 0x7e,
	0x10, 0xcf, 0x33, 0x2c, 0xa9, 0xa6, 0x1e, 0x3f, 0x31, 0xba, 0xa0, 0x06, 0xe8, 0x81, 0xe5, 0x8e,
	0xb0, 0x2c, 0xbd, 0x1f, 0x5e, 0x2d, 0xae, 0x66, 0x52, 0x62, 0x59, 0x42, 0x1c, 0x49, 0x73, 0x92,
	0x1d, 0x4f, 0x67, 0x58, 0x61, 0x46, 0x86, 0x15, 0x58, 0x90, 0xab, 0x6f, 0x15, 0x58, 0x69, 0xbd,
	0xc0, 0x83, 0x63, 0x82, 0x19, 0x73, 0x13, 0x3f, 0x3b, 0xc6, 0x21, 0x41, 0x1b, 0xa0, 0x3f, 0xc1,
	0xd6, 0x30, 0xea, 0xbf, 0x46, 0x3c, 0x20, 0xed, 0xb1, 0x73, 0x53, 0xdc, 0xa3, 0x5d, 0x48, 0x87,
	0x4f, 0xac, 0x40, 0xe4, 0x6d, 0xe3, 0x27, 0x1f, 0xcf, 0x2a, 0xdf, 0x8d, 0xbc, 0xda, 0xc8, 0x7a,
	0x89, 0x09, 0xc1, 0xb5, 0x21, 0x9e, 0x6c, 0x0e, 0xbc, 0x00, 0x6f, 0x0e, 0x3c, 0x37, 0x3c, 0x76,
	0x12, 0x73, 0x7c, 0xad, 0x4b, 0x61, 0xed, 0xa6, 0xc9, 0xf1, 0xe8, 0x0e, 0xa4, 0x9f, 0x51, 0x15,
	0x44, 0x9a, 0xad, 0xcd, 0x31, 0x5f, 0xd6, 0x2c, 0xa3, 0xad, 0x76, 0x61, 0x51, 0xe8, 0x1d, 0xfa,
	0x9e, 0x1b, 0xe2, 0xcf, 0x50, 0xbc, 0x08, 0x99, 0x81, 0xe7, 0xd2, 0x67, 0x47, 0x38, 0x44, 0x6e,
	0xab, 0x7f, 0x52, 0x01, 0xba, 0x83, 0x27, 0xd8, 0xb1, 0x58, 0x47, 0xff, 0x39, 0x64, 0xc5, 0x90,
	0xc7, 0x67, 0x97, 0x7c, 0xfd, 0x7b, 0xc9, 0x57, 0x39, 0xfa, 0x3c, 0x90, 0xc3, 0xa2, 0x24, 0x46,
	0xbf, 0x9e, 0x1a, 0x9f, 0x78, 0x54, 0x67, 0x0d, 0xf2, 0x09, 0x70, 0x72, 0xba, 0xfa, 0x69, 0x3c,
	0x5d, 0xf1, 0x04, 0xbc, 0x34, 0x64, 0x27, 0x80, 0x92, 0x14, 0x6d, 0xd1, 0x21, 0x82, 0x8f, 0x24,
	0xb2, 0x8f, 0x4e, 0x65, 0x7b, 0x3c, 0x1b, 0x0b, 0x64, 0x4c, 0x4e, 0xdb, 0x0c, 0x4d, 0x7d, 0xd9,
	0x3e, 0xcb, 0x57, 0x0f, 0x1f, 0x32, 0x12, 0x0c, 0x82, 0x1e, 0x02, 0x0a, 0xc4, 0x34, 0xc6, 0xde,
	0x3c, 0x3e, 0xc4, 0xe9, 0x8c, 0xd1, 0xcd, 0xa9, 0x58, 0x4e, 0x4f, 0x6c, 0x82, 0x8b, 0x21, 0xc1,
	0x94, 0x3b, 0x1b, 0x44, 0xff, 0xa1, 0xc0, 0xf2, 0x2e, 0x26, 0x3c, 0x10, 0x51, 0x7c, 0x4b, 0x90,
	0xb5, 0xdd, 0x90, 0x58, 0xee, 0x00, 0x8b, 0x09, 0x3c, 0xda, 0xa3, 0xaf, 0xa0, 0xe0, 0x78, 0xc3,
	0x7e, 0x80, 0x27, 0x76, 0xf4, 0xb6, 0xa9, 0x66, 0xde, 0xf1, 0x86, 0xa6, 0x38, 0x42, 0x35, 0xd0,
	0x42, 0x1f, 0x0f, 0x44, 0x1b, 0x48, 0x38, 0x34, 0x8e, 0xb7, 0x6c, 0x02, 0x94, 0x0e, 0xed, 0x81,
	0x31, 0xc4, 0x63, 0x62, 0xf5, 0x7d, 0x2b, 0x20, 0xb6, 0x74, 0xea, 0x35, 0x3e, 0x19, 0x6e, 0x30,
	0xd8, 0xa3, 0x08, 0x55, 0x7d, 0xa3, 0xc0, 0xca, 0x63, 0x7f, 0x68, 0x11, 0x2c, 0x2d, 0xe2, 0x95,
	0xf6, 0x63, 0xb8, 0x81, 0x5f, 0xf8, 0x78, 0x40, 0xfa, 0x91, 0x5d, 0xfc, 0x55, 0x58, 0xe2, 0xc7,
	0x6d, 0x69, 0x5d, 0x0d, 0x56, 0x04, 0xe1, 0x94, 0x91, 0xfc, 0x45, 0x5a, 0xe6, 0x57, 0x9d, 0x84,
	0xa9, 0x75, 0xd0, 0x8f, 0x99, 0x3c, 0x51, 0x50, 0x57, 0x19, 0x2b, 0x28, 0xbf, 0xfe, 0x7d, 0xe2,
	0xcb, 0x94, 0x7e, 0xc1, 0xa1, 0x55, 0x30, 0xda, 0x0f, 0x0e, 0xb6, 0xf7, 0xdb, 0xcd, 0x7e, 0xb3,
	0xdd, 0xe9, 0xf7, 0xfe, 0xf0, 0xa8, 0x65, 0x2c, 0x20, 0x00, 0xfd, 0x60, 0xdb, 0x6c, 0x3f, 0xe8,
	0x19, 0x0a, 0xca, 0x41, 0x7a, 0x67, 0xff, 0xe1, 0x76, 0xcf, 0x50, 0xe9, 0x71, 0xb7, 0x67, 0xb6,
	0x1f, 0xec, 0x1a, 0x1a, 0x5a, 0x84, 0x5c, 0xaf, 0xdd, 0x69, 0x75, 0x7b, 0xdb, 0x9d, 0x47, 0x46,
	0xfa, 0xeb, 0x23, 0xf9, 0xb5, 0xc9, 0xb8, 0xae, 0xc1, 0x8a, 0xe4, 0xda, 0x69, 0xf5, 0xcc, 0xf6,
	0x6f, 0x25, 0xe3, 0x25, 0x00, 0xce, 0xb8, 0xdf, 0x7d, 0xdc, 0x31, 0x14, 0x64, 0x40, 0x41, 0xec,
	0x77, 0xb7, 0x1f, 0xef, 0xb6, 0x8c, 0x14, 0xe5, 0xcb, 0xc4, 0x31, 0x02, 0x95, 0x02, 0xb8, 0xc8,
	0xfe, 0xde, 0xfe, 0xbe, 0xa1, 0xd5, 0xff, 0xaa, 0x80, 0xce, 0xad, 0x43, 0xbf, 0x81, 0x5c, 0x94,
	0x3e, 0xe8, 0x8b, 0x4b, 0x4f, 0x4d, 0x8b, 0x4e, 0x75, 0xa5, 0x44, 0x66, 0x5e, 0xce, 0xb5, 0x16,
	0x14, 0x92, 0x11, 0x43, 0xdf, 0x8f, 0x89, 0x67, 0x44, 0xb2, 0x34, 0x47, 0x46, 0xfd, 0x2f, 0x0a,
	0xa4, 0xf9, 0x33, 0xf5, 0xab, 0xe8, 0xab, 0x88, 0xef, 0x57, 0x66, 0xcc, 0x27, 0xa5, 0x79, 0x8d,
	0x0f, 0xed, 0x41, 0x21, 0xd9, 0xaa, 0x93, 0xea, 0xcc, 0x68, 0xe1, 0x49, 0x3e, 0x53, 0x2d, 0xf2,
	0xb6, 0xd2, 0xb8, 0x75, 0xfa, 0x9f, 0xf2, 0xc2, 0xe9, 0x87, 0xb2, 0xf2, 0xfe, 0x43, 0x59, 0x79,
	0x75, 0x5e, 0x5e, 0x78, 0x7d, 0x5e, 0x56, 0xde, 0x9f, 0x97, 0x17, 0xfe, 0x75, 0x5e, 0x5e, 0x38,
	0xd4, 0x99, 0xfe, 0x77, 0xfe, 0x1f, 0x00, 0x00, 0xff, 0xff, 0xa4, 0x4f, 0xbd, 0x87, 0xb6, 0x11,
	0x00, 0x00,
}

func (this *ResolvedView) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ResolvedView)
	if !ok {
		that2, ok := that.(ResolvedView)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ResolvedView")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ResolvedView but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ResolvedView but is not nil && this == nil")
	}
	if len(this.DimTags) != len(that1.DimTags) {
		return fmt.Errorf("DimTags this(%v) Not Equal that(%v)", len(this.DimTags), len(that1.DimTags))
	}
	for i := range this.DimTags {
		if this.DimTags[i] != that1.DimTags[i] {
			return fmt.Errorf("DimTags this[%v](%v) Not Equal that[%v](%v)", i, this.DimTags[i], i, that1.DimTags[i])
		}
	}
	if len(this.MetTags) != len(that1.MetTags) {
		return fmt.Errorf("MetTags this(%v) Not Equal that(%v)", len(this.MetTags), len(that1.MetTags))
	}
	for i := range this.MetTags {
		if this.MetTags[i] != that1.MetTags[i] {
			return fmt.Errorf("MetTags this[%v](%v) Not Equal that[%v](%v)", i, this.MetTags[i], i, that1.MetTags[i])
		}
	}
	return nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SchemaClient is the client API for Schema service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SchemaClient interface {
	// GetSchema retrieves the current SchemaSpec.
	GetSchema(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetSchemaResponse, error)
	// UpdateSchema updates the SchemaSpec to a new value.
	UpdateSchema(ctx context.Context, in *UpdateSchemaRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type schemaClient struct {
	cc *grpc.ClientConn
}

func NewSchemaClient(cc *grpc.ClientConn) SchemaClient {
	return &schemaClient{cc}
}

func (c *schemaClient) GetSchema(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetSchemaResponse, error) {
	out := new(GetSchemaResponse)
	err := c.cc.Invoke(ctx, "/factable.Schema/GetSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaClient) UpdateSchema(ctx context.Context, in *UpdateSchemaRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/factable.Schema/UpdateSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SchemaServer is the server API for Schema service.
type SchemaServer interface {
	// GetSchema retrieves the current SchemaSpec.
	GetSchema(context.Context, *empty.Empty) (*GetSchemaResponse, error)
	// UpdateSchema updates the SchemaSpec to a new value.
	UpdateSchema(context.Context, *UpdateSchemaRequest) (*empty.Empty, error)
}

// UnimplementedSchemaServer can be embedded to have forward compatible implementations.
type UnimplementedSchemaServer struct {
}

func (*UnimplementedSchemaServer) GetSchema(ctx context.Context, req *empty.Empty) (*GetSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSchema not implemented")
}
func (*UnimplementedSchemaServer) UpdateSchema(ctx context.Context, req *UpdateSchemaRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSchema not implemented")
}

func RegisterSchemaServer(s *grpc.Server, srv SchemaServer) {
	s.RegisterService(&_Schema_serviceDesc, srv)
}

func _Schema_GetSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaServer).GetSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/factable.Schema/GetSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaServer).GetSchema(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schema_UpdateSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaServer).UpdateSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/factable.Schema/UpdateSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaServer).UpdateSchema(ctx, req.(*UpdateSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Schema_serviceDesc = grpc.ServiceDesc{
	ServiceName: "factable.Schema",
	HandlerType: (*SchemaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSchema",
			Handler:    _Schema_GetSchema_Handler,
		},
		{
			MethodName: "UpdateSchema",
			Handler:    _Schema_UpdateSchema_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/factable/factable.proto",
}

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// ResolveQuery maps a QuerySpec into a validated ResolvedQuery,
	// under the current server schema.
	ResolveQuery(ctx context.Context, in *QuerySpec, opts ...grpc.CallOption) (*ResolvedQuery, error)
	// ExecuteResolvedQuery against one or all Shards.
	ExecuteQuery(ctx context.Context, in *ExecuteQueryRequest, opts ...grpc.CallOption) (Query_ExecuteQueryClient, error)
}

type queryClient struct {
	cc *grpc.ClientConn
}

func NewQueryClient(cc *grpc.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) ResolveQuery(ctx context.Context, in *QuerySpec, opts ...grpc.CallOption) (*ResolvedQuery, error) {
	out := new(ResolvedQuery)
	err := c.cc.Invoke(ctx, "/factable.Query/ResolveQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ExecuteQuery(ctx context.Context, in *ExecuteQueryRequest, opts ...grpc.CallOption) (Query_ExecuteQueryClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Query_serviceDesc.Streams[0], "/factable.Query/ExecuteQuery", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryExecuteQueryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_ExecuteQueryClient interface {
	Recv() (*QueryResponse, error)
	grpc.ClientStream
}

type queryExecuteQueryClient struct {
	grpc.ClientStream
}

func (x *queryExecuteQueryClient) Recv() (*QueryResponse, error) {
	m := new(QueryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// ResolveQuery maps a QuerySpec into a validated ResolvedQuery,
	// under the current server schema.
	ResolveQuery(context.Context, *QuerySpec) (*ResolvedQuery, error)
	// ExecuteResolvedQuery against one or all Shards.
	ExecuteQuery(*ExecuteQueryRequest, Query_ExecuteQueryServer) error
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) ResolveQuery(ctx context.Context, req *QuerySpec) (*ResolvedQuery, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveQuery not implemented")
}
func (*UnimplementedQueryServer) ExecuteQuery(req *ExecuteQueryRequest, srv Query_ExecuteQueryServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecuteQuery not implemented")
}

func RegisterQueryServer(s *grpc.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_ResolveQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ResolveQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/factable.Query/ResolveQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ResolveQuery(ctx, req.(*QuerySpec))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ExecuteQuery_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecuteQueryRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).ExecuteQuery(m, &queryExecuteQueryServer{stream})
}

type Query_ExecuteQueryServer interface {
	Send(*QueryResponse) error
	grpc.ServerStream
}

type queryExecuteQueryServer struct {
	grpc.ServerStream
}

func (x *queryExecuteQueryServer) Send(m *QueryResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "factable.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResolveQuery",
			Handler:    _Query_ResolveQuery_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ExecuteQuery",
			Handler:       _Query_ExecuteQuery_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/factable/factable.proto",
}

func (m *MappingSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MappingSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DimensionSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DimensionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DimensionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DimTag != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.DimTag))
		i--
		dAtA[i] = 0x30
	}
	if m.Tag != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Dimension) > 0 {
		i -= len(m.Dimension)
		copy(dAtA[i:], m.Dimension)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Dimension)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RelationSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelationSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DimTags) > 0 {
		dAtA2 := make([]byte, len(m.DimTags)*10)
		var j1 int
		for _, num := range m.DimTags {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintFactable(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x42
	}
	if m.MapTag != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.MapTag))
		i--
		dAtA[i] = 0x38
	}
	if m.Tag != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Dimensions) > 0 {
		for iNdEx := len(m.Dimensions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Dimensions[iNdEx])
			copy(dAtA[i:], m.Dimensions[iNdEx])
			i = encodeVarintFactable(dAtA, i, uint64(len(m.Dimensions[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Mapping) > 0 {
		i -= len(m.Mapping)
		copy(dAtA[i:], m.Mapping)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Mapping)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Selector.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFactable(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ViewSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Metrics[iNdEx])
			copy(dAtA[i:], m.Metrics[iNdEx])
			i = encodeVarintFactable(dAtA, i, uint64(len(m.Metrics[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Dimensions) > 0 {
		for iNdEx := len(m.Dimensions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Dimensions[iNdEx])
			copy(dAtA[i:], m.Dimensions[iNdEx])
			i = encodeVarintFactable(dAtA, i, uint64(len(m.Dimensions[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResolvedView) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolvedView) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolvedView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MetTags) > 0 {
		dAtA5 := make([]byte, len(m.MetTags)*10)
		var j4 int
		for _, num := range m.MetTags {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintFactable(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DimTags) > 0 {
		dAtA7 := make([]byte, len(m.DimTags)*10)
		var j6 int
		for _, num := range m.DimTags {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintFactable(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReservedMVTagSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReservedMVTagSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReservedMVTagSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x12
	}
	if m.Tag != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MaterializedViewSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterializedViewSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaterializedViewSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResolvedView.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFactable(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.RelTag != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.RelTag))
		i--
		dAtA[i] = 0x38
	}
	if m.Tag != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x30
	}
	if m.Retention != nil {
		{
			size, err := m.Retention.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFactable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.View.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFactable(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Relation) > 0 {
		i -= len(m.Relation)
		copy(dAtA[i:], m.Relation)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Relation)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MaterializedViewSpec_Retention) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterializedViewSpec_Retention) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaterializedViewSpec_Retention) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RelativeToTag != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.RelativeToTag))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RelativeTo) > 0 {
		i -= len(m.RelativeTo)
		copy(dAtA[i:], m.RelativeTo)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.RelativeTo)))
		i--
		dAtA[i] = 0x12
	}
	n11, err11 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.RemoveAfter, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.RemoveAfter):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintFactable(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QuerySpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFactable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.View.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFactable(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.MaterializedView) > 0 {
		i -= len(m.MaterializedView)
		copy(dAtA[i:], m.MaterializedView)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.MaterializedView)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *QuerySpec_Filter) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpec_Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySpec_Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Times) > 0 {
		for iNdEx := len(m.Times) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Times[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFactable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Strings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFactable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Floats) > 0 {
		for iNdEx := len(m.Floats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Floats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFactable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Ints) > 0 {
		for iNdEx := len(m.Ints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFactable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Dimension) > 0 {
		i -= len(m.Dimension)
		copy(dAtA[i:], m.Dimension)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Dimension)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySpec_Filter_Int) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpec_Filter_Int) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySpec_Filter_Int) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Begin != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QuerySpec_Filter_Float) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpec_Filter_Float) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySpec_Filter_Float) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.End))))
		i--
		dAtA[i] = 0x11
	}
	if m.Begin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Begin))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *QuerySpec_Filter_String) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpec_Filter_String) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySpec_Filter_String) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.End) > 0 {
		i -= len(m.End)
		copy(dAtA[i:], m.End)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.End)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Begin) > 0 {
		i -= len(m.Begin)
		copy(dAtA[i:], m.Begin)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Begin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySpec_Filter_Time) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpec_Filter_Time) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySpec_Filter_Time) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n13, err13 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.RelativeEnd, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.RelativeEnd):])
	if err13 != nil {
		return 0, err13
	}
	i -= n13
	i = encodeVarintFactable(dAtA, i, uint64(n13))
	i--
	dAtA[i] = 0x22
	n14, err14 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.RelativeBegin, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.RelativeBegin):])
	if err14 != nil {
		return 0, err14
	}
	i -= n14
	i = encodeVarintFactable(dAtA, i, uint64(n14))
	i--
	dAtA[i] = 0x1a
	n15, err15 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.End, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.End):])
	if err15 != nil {
		return 0, err15
	}
	i -= n15
	i = encodeVarintFactable(dAtA, i, uint64(n15))
	i--
	dAtA[i] = 0x12
	n16, err16 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Begin, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Begin):])
	if err16 != nil {
		return 0, err16
	}
	i -= n16
	i = encodeVarintFactable(dAtA, i, uint64(n16))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResolvedQuery) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolvedQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolvedQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFactable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.View.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFactable(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.MvTag != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.MvTag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResolvedQuery_Filter) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolvedQuery_Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolvedQuery_Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ranges) > 0 {
		for iNdEx := len(m.Ranges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ranges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFactable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DimTag != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.DimTag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResolvedQuery_Filter_Range) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolvedQuery_Filter_Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolvedQuery_Filter_Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.End) > 0 {
		i -= len(m.End)
		copy(dAtA[i:], m.End)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.End)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Begin) > 0 {
		i -= len(m.Begin)
		copy(dAtA[i:], m.Begin)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Begin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecuteQueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFactable(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Shard) > 0 {
		i -= len(m.Shard)
		copy(dAtA[i:], m.Shard)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Shard)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFactable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFactable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchemaSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReservedViewTags) > 0 {
		for iNdEx := len(m.ReservedViewTags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReservedViewTags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFactable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Views) > 0 {
		for iNdEx := len(m.Views) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Views[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFactable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Relations) > 0 {
		for iNdEx := len(m.Relations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Relations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFactable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFactable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Dimensions) > 0 {
		for iNdEx := len(m.Dimensions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Dimensions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFactable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Mappings) > 0 {
		for iNdEx := len(m.Mappings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Mappings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFactable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSchemaResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSchemaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSchemaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.DeltaPartitions.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFactable(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Instance) > 0 {
		i -= len(m.Instance)
		copy(dAtA[i:], m.Instance)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Instance)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFactable(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ModRevision != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.ModRevision))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSchemaRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSchemaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSchemaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Update.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFactable(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ExpectModRevision != 0 {
		i = encodeVarintFactable(dAtA, i, uint64(m.ExpectModRevision))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ExpectInstance) > 0 {
		i -= len(m.ExpectInstance)
		copy(dAtA[i:], m.ExpectInstance)
		i = encodeVarintFactable(dAtA, i, uint64(len(m.ExpectInstance)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFactable(dAtA []byte, offset int, v uint64) int {
	offset -= sovFactable(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MappingSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.Tag != 0 {
		n += 1 + sovFactable(uint64(m.Tag))
	}
	return n
}

func (m *DimensionSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovFactable(uint64(m.Type))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.Tag != 0 {
		n += 1 + sovFactable(uint64(m.Tag))
	}
	return n
}

func (m *MetricSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = len(m.Dimension)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovFactable(uint64(m.Type))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.Tag != 0 {
		n += 1 + sovFactable(uint64(m.Tag))
	}
	if m.DimTag != 0 {
		n += 1 + sovFactable(uint64(m.DimTag))
	}
	return n
}

func (m *RelationSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = m.Selector.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	l = len(m.Mapping)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	if len(m.Dimensions) > 0 {
		for _, s := range m.Dimensions {
			l = len(s)
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.Tag != 0 {
		n += 1 + sovFactable(uint64(m.Tag))
	}
	if m.MapTag != 0 {
		n += 1 + sovFactable(uint64(m.MapTag))
	}
	if len(m.DimTags) > 0 {
		l = 0
		for _, e := range m.DimTags {
			l += sovFactable(uint64(e))
		}
		n += 1 + sovFactable(uint64(l)) + l
	}
	return n
}

func (m *ViewSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dimensions) > 0 {
		for _, s := range m.Dimensions {
			l = len(s)
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	if len(m.Metrics) > 0 {
		for _, s := range m.Metrics {
			l = len(s)
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	return n
}

func (m *ResolvedView) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DimTags) > 0 {
		l = 0
		for _, e := range m.DimTags {
			l += sovFactable(uint64(e))
		}
		n += 1 + sovFactable(uint64(l)) + l
	}
	if len(m.MetTags) > 0 {
		l = 0
		for _, e := range m.MetTags {
			l += sovFactable(uint64(e))
		}
		n += 1 + sovFactable(uint64(l)) + l
	}
	return n
}

func (m *ReservedMVTagSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovFactable(uint64(m.Tag))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	return n
}

func (m *MaterializedViewSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = len(m.Relation)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = m.View.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.Retention != nil {
		l = m.Retention.ProtoSize()
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.Tag != 0 {
		n += 1 + sovFactable(uint64(m.Tag))
	}
	if m.RelTag != 0 {
		n += 1 + sovFactable(uint64(m.RelTag))
	}
	l = m.ResolvedView.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	return n
}

func (m *MaterializedViewSpec_Retention) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.RemoveAfter)
	n += 1 + l + sovFactable(uint64(l))
	l = len(m.RelativeTo)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.RelativeToTag != 0 {
		n += 1 + sovFactable(uint64(m.RelativeToTag))
	}
	return n
}

func (m *QuerySpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MaterializedView)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = m.View.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	return n
}

func (m *QuerySpec_Filter) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Dimension)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	if len(m.Ints) > 0 {
		for _, e := range m.Ints {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	if len(m.Floats) > 0 {
		for _, e := range m.Floats {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	if len(m.Strings) > 0 {
		for _, e := range m.Strings {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	if len(m.Times) > 0 {
		for _, e := range m.Times {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	return n
}

func (m *QuerySpec_Filter_Int) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != 0 {
		n += 1 + sovFactable(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovFactable(uint64(m.End))
	}
	return n
}

func (m *QuerySpec_Filter_Float) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != 0 {
		n += 9
	}
	if m.End != 0 {
		n += 9
	}
	return n
}

func (m *QuerySpec_Filter_String) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Begin)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	return n
}

func (m *QuerySpec_Filter_Time) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Begin)
	n += 1 + l + sovFactable(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.End)
	n += 1 + l + sovFactable(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.RelativeBegin)
	n += 1 + l + sovFactable(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.RelativeEnd)
	n += 1 + l + sovFactable(uint64(l))
	return n
}

func (m *ResolvedQuery) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MvTag != 0 {
		n += 1 + sovFactable(uint64(m.MvTag))
	}
	l = m.View.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	return n
}

func (m *ResolvedQuery_Filter) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DimTag != 0 {
		n += 1 + sovFactable(uint64(m.DimTag))
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	return n
}

func (m *ResolvedQuery_Filter_Range) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Begin)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	return n
}

func (m *ExecuteQueryRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovFactable(uint64(l))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = m.Query.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	return n
}

func (m *QueryResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovFactable(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	return n
}

func (m *SchemaSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Mappings) > 0 {
		for _, e := range m.Mappings {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	if len(m.Dimensions) > 0 {
		for _, e := range m.Dimensions {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	if len(m.Relations) > 0 {
		for _, e := range m.Relations {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	if len(m.Views) > 0 {
		for _, e := range m.Views {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	if len(m.ReservedViewTags) > 0 {
		for _, e := range m.ReservedViewTags {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	return n
}

func (m *GetSchemaResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ModRevision != 0 {
		n += 1 + sovFactable(uint64(m.ModRevision))
	}
	l = m.Spec.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = m.DeltaPartitions.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	return n
}

func (m *UpdateSchemaRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExpectInstance)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.ExpectModRevision != 0 {
		n += 1 + sovFactable(uint64(m.ExpectModRevision))
	}
	l = m.Update.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	return n
}

func sovFactable(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFactable(x uint64) (n int) {
	return sovFactable(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MappingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= MapTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DimensionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DimensionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DimensionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DimensionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= DimTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimension", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dimension = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MetricType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= MetTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DimTag", wireType)
			}
			m.DimTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DimTag |= DimTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mapping", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mapping = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimensions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dimensions = append(m.Dimensions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= RelTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapTag", wireType)
			}
			m.MapTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapTag |= MapTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v DimTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFactable
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= DimTag(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DimTags = append(m.DimTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFactable
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFactable
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFactable
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DimTags) == 0 {
					m.DimTags = make([]DimTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v DimTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFactable
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= DimTag(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DimTags = append(m.DimTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DimTags", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimensions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dimensions = append(m.Dimensions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolvedView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolvedView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolvedView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v DimTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFactable
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= DimTag(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DimTags = append(m.DimTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFactable
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFactable
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFactable
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DimTags) == 0 {
					m.DimTags = make([]DimTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v DimTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFactable
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= DimTag(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DimTags = append(m.DimTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DimTags", wireType)
			}
		case 2:
			if wireType == 0 {
				var v MetTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFactable
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= MetTag(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MetTags = append(m.MetTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFactable
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFactable
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFactable
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MetTags) == 0 {
					m.MetTags = make([]MetTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v MetTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFactable
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= MetTag(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MetTags = append(m.MetTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MetTags", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReservedMVTagSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReservedMVTagSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReservedMVTagSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= MVTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterializedViewSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaterializedViewSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaterializedViewSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.View.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retention", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Retention == nil {
				m.Retention = &MaterializedViewSpec_Retention{}
			}
			if err := m.Retention.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= MVTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelTag", wireType)
			}
			m.RelTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelTag |= RelTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResolvedView.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterializedViewSpec_Retention) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Retention: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Retention: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.RemoveAfter, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelativeTo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeToTag", wireType)
			}
			m.RelativeToTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelativeToTag |= DimTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaterializedView", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaterializedView = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.View.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, QuerySpec_Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpec_Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimension", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dimension = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ints = append(m.Ints, QuerySpec_Filter_Int{})
			if err := m.Ints[len(m.Ints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Floats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Floats = append(m.Floats, QuerySpec_Filter_Float{})
			if err := m.Floats[len(m.Floats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, QuerySpec_Filter_String{})
			if err := m.Strings[len(m.Strings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Times = append(m.Times, QuerySpec_Filter_Time{})
			if err := m.Times[len(m.Times)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpec_Filter_Int) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpec_Filter_Float) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Float: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Float: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Begin = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.End = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpec_Filter_String) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: String: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: String: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Begin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpec_Filter_Time) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Time: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Time: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Begin, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.End, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeBegin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.RelativeBegin, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.RelativeEnd, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolvedQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolvedQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolvedQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvTag", wireType)
			}
			m.MvTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MvTag |= MVTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.View.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, ResolvedQuery_Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolvedQuery_Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DimTag", wireType)
			}
			m.DimTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DimTag |= DimTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, ResolvedQuery_Filter_Range{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolvedQuery_Filter_Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Begin = append(m.Begin[:0], dAtA[iNdEx:postIndex]...)
			if m.Begin == nil {
				m.Begin = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &protocol.Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = go_gazette_dev_core_consumer_protocol.ShardID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &protocol.Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mappings = append(m.Mappings, MappingSpec{})
			if err := m.Mappings[len(m.Mappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dimensions = append(m.Dimensions, DimensionSpec{})
			if err := m.Dimensions[len(m.Dimensions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, MetricSpec{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relations = append(m.Relations, RelationSpec{})
			if err := m.Relations[len(m.Relations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Views", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Views = append(m.Views, MaterializedViewSpec{})
			if err := m.Views[len(m.Views)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedViewTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReservedViewTags = append(m.ReservedViewTags, ReservedMVTagSpec{})
			if err := m.ReservedViewTags[len(m.ReservedViewTags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSchemaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSchemaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSchemaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModRevision", wireType)
			}
			m.ModRevision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModRevision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaPartitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeltaPartitions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSchemaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSchemaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSchemaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectInstance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectInstance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectModRevision", wireType)
			}
			m.ExpectModRevision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectModRevision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFactable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Update.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFactable(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFactable
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFactable
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFactable
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFactable        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFactable          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFactable = fmt.Errorf("proto: unexpected end of group")
)
