// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: factable.proto

package factable

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import protocol "github.com/LiveRamp/gazette/v2/pkg/protocol"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/golang/protobuf/ptypes/duration"
import empty "github.com/golang/protobuf/ptypes/empty"
import _ "github.com/golang/protobuf/ptypes/timestamp"

import time "time"
import github_com_LiveRamp_gazette_v2_pkg_consumer "github.com/LiveRamp/gazette/v2/pkg/consumer"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"
import github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type DimensionType int32

const (
	DimensionType_INVALID_DIM_TYPE DimensionType = 0
	DimensionType_VARINT           DimensionType = 1
	DimensionType_FLOAT            DimensionType = 3
	DimensionType_STRING           DimensionType = 4
	DimensionType_TIMESTAMP        DimensionType = 5
)

var DimensionType_name = map[int32]string{
	0: "INVALID_DIM_TYPE",
	1: "VARINT",
	3: "FLOAT",
	4: "STRING",
	5: "TIMESTAMP",
}
var DimensionType_value = map[string]int32{
	"INVALID_DIM_TYPE": 0,
	"VARINT":           1,
	"FLOAT":            3,
	"STRING":           4,
	"TIMESTAMP":        5,
}

func (x DimensionType) String() string {
	return proto.EnumName(DimensionType_name, int32(x))
}
func (DimensionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{0}
}

type MetricType int32

const (
	MetricType_INVALID_METRIC_TYPE MetricType = 0
	MetricType_VARINT_SUM          MetricType = 1
	MetricType_VARINT_GUAGE        MetricType = 2
	MetricType_FLOAT_SUM           MetricType = 3
	MetricType_STRING_HLL          MetricType = 4
)

var MetricType_name = map[int32]string{
	0: "INVALID_METRIC_TYPE",
	1: "VARINT_SUM",
	2: "VARINT_GUAGE",
	3: "FLOAT_SUM",
	4: "STRING_HLL",
}
var MetricType_value = map[string]int32{
	"INVALID_METRIC_TYPE": 0,
	"VARINT_SUM":          1,
	"VARINT_GUAGE":        2,
	"FLOAT_SUM":           3,
	"STRING_HLL":          4,
}

func (x MetricType) String() string {
	return proto.EnumName(MetricType_name, int32(x))
}
func (MetricType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{1}
}

// MappingSpec defines a Mapping of input Messages to InputRecords. In many
// cases, Relations will opt to use an identity Mapping. For events having
// de-normalized & nested event structures, Mappings provide a means to
// "unpack" into multiple normalized RelationRows. For example a "purchase"
// event having several product SKUs might map to a RelationRow{purchase, SKU}
// tuple for each purchased product.
type MappingSpec struct {
	// Unique tag of the Mapping. Immutable.
	Tag MapTag `protobuf:"varint,1,opt,name=tag,proto3,casttype=MapTag" json:"tag,omitempty"`
	// Short, unique name of the Mapping.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Longer, free-form description of the Mapping.
	Desc string `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *MappingSpec) Reset()         { *m = MappingSpec{} }
func (m *MappingSpec) String() string { return proto.CompactTextString(m) }
func (*MappingSpec) ProtoMessage()    {}
func (*MappingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{0}
}
func (m *MappingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MappingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingSpec.Merge(dst, src)
}
func (m *MappingSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MappingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MappingSpec proto.InternalMessageInfo

// DimensionSpec defines a Dimension which may be extracted from a RelationRow.
type DimensionSpec struct {
	// Unique tag of the dimension. Immutable.
	Tag DimTag `protobuf:"varint,1,opt,name=tag,proto3,casttype=DimTag" json:"tag,omitempty"`
	// Type of the Dimension. Immutable.
	Type DimensionType `protobuf:"varint,2,opt,name=type,proto3,enum=factable.DimensionType" json:"type,omitempty"`
	// Short, unique name of the Dimension.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Longer, free-form description of the Dimension.
	Desc string `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *DimensionSpec) Reset()         { *m = DimensionSpec{} }
func (m *DimensionSpec) String() string { return proto.CompactTextString(m) }
func (*DimensionSpec) ProtoMessage()    {}
func (*DimensionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{1}
}
func (m *DimensionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DimensionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DimensionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DimensionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DimensionSpec.Merge(dst, src)
}
func (m *DimensionSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DimensionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DimensionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DimensionSpec proto.InternalMessageInfo

// MetricSpec defines a Metric which may be derived from a specified Dimension.
type MetricSpec struct {
	// Unique tag of the Metric. Immutable.
	Tag MetTag `protobuf:"varint,1,opt,name=tag,proto3,casttype=MetTag" json:"tag,omitempty"`
	// Type of the Metric. Immutable.
	Type MetricType `protobuf:"varint,2,opt,name=type,proto3,enum=factable.MetricType" json:"type,omitempty"`
	// Dimension tag from which the Metric is extracted. Immutable.
	DimTag DimTag `protobuf:"varint,3,opt,name=dim_tag,json=dimTag,proto3,casttype=DimTag" json:"dim_tag,omitempty"`
	// Short, unique name of the Metric.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// Longer, free-form description of the Metric.
	Desc string `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *MetricSpec) Reset()         { *m = MetricSpec{} }
func (m *MetricSpec) String() string { return proto.CompactTextString(m) }
func (*MetricSpec) ProtoMessage()    {}
func (*MetricSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{2}
}
func (m *MetricSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MetricSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricSpec.Merge(dst, src)
}
func (m *MetricSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MetricSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MetricSpec proto.InternalMessageInfo

// RelationSpec composes a journal LabelSelector, which defines a collection of
// input events, with a mapping that transforms each event into one or more
// RelationRows.
type RelationSpec struct {
	// Unique tag of the Relation. Immutable.
	Tag RelTag `protobuf:"varint,1,opt,name=tag,proto3,casttype=RelTag" json:"tag,omitempty"`
	// Mapping which transforms journal events into Relation rows. Immutable.
	Mapping MapTag `protobuf:"varint,2,opt,name=mapping,proto3,casttype=MapTag" json:"mapping,omitempty"`
	// Short, unique name of the Relation.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Longer, free-form description of the Relation.
	Desc string `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
	// LabelSelector identifies journals which, taken together, compose the "rows" of the Relation.
	Selector protocol.LabelSelector `protobuf:"bytes,5,opt,name=selector" json:"selector"`
	// Dimensions of the Relation. Dimensions may be added and removed over time,
	// but all Dimensions or derived Metrics of current MaterializedViewSpecs must
	// refer to current Dimensions of the RelationSpec.
	Dimensions []DimTag `protobuf:"varint,6,rep,packed,name=dimensions,casttype=DimTag" json:"dimensions,omitempty"`
}

func (m *RelationSpec) Reset()         { *m = RelationSpec{} }
func (m *RelationSpec) String() string { return proto.CompactTextString(m) }
func (*RelationSpec) ProtoMessage()    {}
func (*RelationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{3}
}
func (m *RelationSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelationSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RelationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelationSpec.Merge(dst, src)
}
func (m *RelationSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RelationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RelationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RelationSpec proto.InternalMessageInfo

// ViewSpec defines a summarized view over a Relation, composing a subset of
// Relation dimensions with a set of derived Metrics.
type ViewSpec struct {
	// Tag of the Relation summarized by the View.
	RelTag RelTag `protobuf:"varint,1,opt,name=rel_tag,json=relTag,proto3,casttype=RelTag" json:"rel_tag,omitempty"`
	// Ordered Dimensions of each View row.
	Dimensions []DimTag `protobuf:"varint,2,rep,packed,name=dimensions,casttype=DimTag" json:"dimensions,omitempty"`
	// Ordered Metrics of each View row.
	Metrics []MetTag `protobuf:"varint,3,rep,packed,name=metrics,casttype=MetTag" json:"metrics,omitempty"`
}

func (m *ViewSpec) Reset()         { *m = ViewSpec{} }
func (m *ViewSpec) String() string { return proto.CompactTextString(m) }
func (*ViewSpec) ProtoMessage()    {}
func (*ViewSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{4}
}
func (m *ViewSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ViewSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewSpec.Merge(dst, src)
}
func (m *ViewSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ViewSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ViewSpec proto.InternalMessageInfo

// MaterializedViewSpec defines a materialization of a ViewSpec. Its Metrics
// are continuously aggregated as RelationRows are processed, and the total
// storage commitment is limited to the cardinality of the View Dimensions.
type MaterializedViewSpec struct {
	// Unique tag of the MaterializedView. Immutable.
	Tag MVTag `protobuf:"varint,1,opt,name=tag,proto3,casttype=MVTag" json:"tag,omitempty"`
	// View materialized by the MaterializedView. Immutable.
	View ViewSpec `protobuf:"bytes,2,opt,name=view" json:"view"`
	// Short, unique name of the MaterializedView.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Longer, free-form description of the MaterializedView.
	Desc      string                          `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
	Retention *MaterializedViewSpec_Retention `protobuf:"bytes,5,opt,name=retention" json:"retention,omitempty"`
}

func (m *MaterializedViewSpec) Reset()         { *m = MaterializedViewSpec{} }
func (m *MaterializedViewSpec) String() string { return proto.CompactTextString(m) }
func (*MaterializedViewSpec) ProtoMessage()    {}
func (*MaterializedViewSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{5}
}
func (m *MaterializedViewSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterializedViewSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaterializedViewSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MaterializedViewSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterializedViewSpec.Merge(dst, src)
}
func (m *MaterializedViewSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaterializedViewSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterializedViewSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MaterializedViewSpec proto.InternalMessageInfo

// Optional retention of MaterializedView rows.
type MaterializedViewSpec_Retention struct {
	// Duration after which a row is eligible for removal.
	RemoveAfter time.Duration `protobuf:"bytes,1,opt,name=remove_after,json=removeAfter,stdduration" json:"remove_after"`
	// Dimension, which must be part of the MaterializedView and of type
	// Timestamp, to which |remove_after| is added to determine the effective
	// removal horizon.
	RelativeTo DimTag `protobuf:"varint,2,opt,name=relative_to,json=relativeTo,proto3,casttype=DimTag" json:"relative_to,omitempty"`
}

func (m *MaterializedViewSpec_Retention) Reset()         { *m = MaterializedViewSpec_Retention{} }
func (m *MaterializedViewSpec_Retention) String() string { return proto.CompactTextString(m) }
func (*MaterializedViewSpec_Retention) ProtoMessage()    {}
func (*MaterializedViewSpec_Retention) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{5, 0}
}
func (m *MaterializedViewSpec_Retention) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterializedViewSpec_Retention) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaterializedViewSpec_Retention.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MaterializedViewSpec_Retention) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterializedViewSpec_Retention.Merge(dst, src)
}
func (m *MaterializedViewSpec_Retention) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaterializedViewSpec_Retention) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterializedViewSpec_Retention.DiscardUnknown(m)
}

var xxx_messageInfo_MaterializedViewSpec_Retention proto.InternalMessageInfo

// QuerySpec describes a result which should be computed from a Relation.
// In particular it defines the "shape" (in Dimensions and Metrics) of the
// desired result, and any filters which should be applied.
type QuerySpec struct {
	// View of the Query result.
	//
	// Dimensions of the Relation which should be grouped over and returned with
	// the Query result set. Other Dimensions included in the MaterializedView but
	// not included in the Query Shape are aggregated across.
	//
	// Where possible, use a strict ordered prefix of underlying MaterializedView
	// Dimensions. This is much more efficient to evaluate, as grouping can
	// utilize the natural index order, and no further recombining or sorting is
	// required. When using a prefix, the Query result set is incrementally
	// streamed as it is evaluated, and even extremely large result sets can be
	// queried efficiently.
	//
	// If Dimensions are not a strict prefix, the Query evaluator must perform
	// recombination and sorting steps, and results will be sent only after
	// all underlying view rows have been read. Implementations may also limit
	// the size of the result sets they will buffer, returning an error for
	// Queries which exceed it.
	View    ViewSpec           `protobuf:"bytes,1,opt,name=view" json:"view"`
	Filters []QuerySpec_Filter `protobuf:"bytes,2,rep,name=filters" json:"filters"`
}

func (m *QuerySpec) Reset()         { *m = QuerySpec{} }
func (m *QuerySpec) String() string { return proto.CompactTextString(m) }
func (*QuerySpec) ProtoMessage()    {}
func (*QuerySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{6}
}
func (m *QuerySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QuerySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpec.Merge(dst, src)
}
func (m *QuerySpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *QuerySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpec.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpec proto.InternalMessageInfo

// A Filter is a sequence of ordered non-overlapping ranges for a Dimension.
// Filters may be applied to any subset of MaterializedView Dimensions,
// including those not present in the Query View.
type QuerySpec_Filter struct {
	// Dimension to which the Filter is applied.
	Dimension DimTag `protobuf:"varint,1,opt,name=dimension,proto3,casttype=DimTag" json:"dimension,omitempty"`
	// Admissible Dimension ranges. The subtype of each Range must match that
	// of the Relation Dimension itself.
	Ranges []Range `protobuf:"bytes,2,rep,name=ranges" json:"ranges"`
}

func (m *QuerySpec_Filter) Reset()         { *m = QuerySpec_Filter{} }
func (m *QuerySpec_Filter) String() string { return proto.CompactTextString(m) }
func (*QuerySpec_Filter) ProtoMessage()    {}
func (*QuerySpec_Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{6, 0}
}
func (m *QuerySpec_Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpec_Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpec_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QuerySpec_Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpec_Filter.Merge(dst, src)
}
func (m *QuerySpec_Filter) XXX_Size() int {
	return m.ProtoSize()
}
func (m *QuerySpec_Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpec_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpec_Filter proto.InternalMessageInfo

// Range is Begin & End values (inclusive) as a union type. If Begin is omitted,
// it is interpreted as matching any lesser value. Similarly if End is omitted,
// it is interpreted as matching any greater value.
type Range struct {
	Int   *Range_Int    `protobuf:"bytes,1,opt,name=int" json:"int,omitempty"`
	Float *Range_Float  `protobuf:"bytes,2,opt,name=float" json:"float,omitempty"`
	Str   *Range_String `protobuf:"bytes,3,opt,name=str" json:"str,omitempty"`
	Time  *Range_Time   `protobuf:"bytes,4,opt,name=time" json:"time,omitempty"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{7}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(dst, src)
}
func (m *Range) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

type Range_Int struct {
	Begin int64 `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End   int64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *Range_Int) Reset()         { *m = Range_Int{} }
func (m *Range_Int) String() string { return proto.CompactTextString(m) }
func (*Range_Int) ProtoMessage()    {}
func (*Range_Int) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{7, 0}
}
func (m *Range_Int) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range_Int) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range_Int.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Range_Int) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range_Int.Merge(dst, src)
}
func (m *Range_Int) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Range_Int) XXX_DiscardUnknown() {
	xxx_messageInfo_Range_Int.DiscardUnknown(m)
}

var xxx_messageInfo_Range_Int proto.InternalMessageInfo

type Range_Float struct {
	Begin float64 `protobuf:"fixed64,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End   float64 `protobuf:"fixed64,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *Range_Float) Reset()         { *m = Range_Float{} }
func (m *Range_Float) String() string { return proto.CompactTextString(m) }
func (*Range_Float) ProtoMessage()    {}
func (*Range_Float) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{7, 1}
}
func (m *Range_Float) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range_Float) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range_Float.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Range_Float) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range_Float.Merge(dst, src)
}
func (m *Range_Float) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Range_Float) XXX_DiscardUnknown() {
	xxx_messageInfo_Range_Float.DiscardUnknown(m)
}

var xxx_messageInfo_Range_Float proto.InternalMessageInfo

type Range_String struct {
	Begin string `protobuf:"bytes,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End   string `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *Range_String) Reset()         { *m = Range_String{} }
func (m *Range_String) String() string { return proto.CompactTextString(m) }
func (*Range_String) ProtoMessage()    {}
func (*Range_String) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{7, 2}
}
func (m *Range_String) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range_String) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range_String.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Range_String) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range_String.Merge(dst, src)
}
func (m *Range_String) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Range_String) XXX_DiscardUnknown() {
	xxx_messageInfo_Range_String.DiscardUnknown(m)
}

var xxx_messageInfo_Range_String proto.InternalMessageInfo

type Range_Time struct {
	Begin time.Time `protobuf:"bytes,1,opt,name=begin,stdtime" json:"begin"`
	End   time.Time `protobuf:"bytes,2,opt,name=end,stdtime" json:"end"`
}

func (m *Range_Time) Reset()         { *m = Range_Time{} }
func (m *Range_Time) String() string { return proto.CompactTextString(m) }
func (*Range_Time) ProtoMessage()    {}
func (*Range_Time) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{7, 3}
}
func (m *Range_Time) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range_Time) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range_Time.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Range_Time) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range_Time.Merge(dst, src)
}
func (m *Range_Time) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Range_Time) XXX_DiscardUnknown() {
	xxx_messageInfo_Range_Time.DiscardUnknown(m)
}

var xxx_messageInfo_Range_Time proto.InternalMessageInfo

type QueryRequest struct {
	// Header attached by a proxy-ing peer. Not directly set by clients.
	Header *protocol.Header `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	// MaterializedView to query.
	View MVTag `protobuf:"varint,2,opt,name=view,proto3,casttype=MVTag" json:"view,omitempty"`
	// Shard to query. Set iff |header| is also set.
	Shard github_com_LiveRamp_gazette_v2_pkg_consumer.ShardID `protobuf:"bytes,3,opt,name=shard,proto3,casttype=github.com/LiveRamp/gazette/v2/pkg/consumer.ShardID" json:"shard,omitempty"`
	// Query specification.
	Query QuerySpec `protobuf:"bytes,4,opt,name=query" json:"query"`
}

func (m *QueryRequest) Reset()         { *m = QueryRequest{} }
func (m *QueryRequest) String() string { return proto.CompactTextString(m) }
func (*QueryRequest) ProtoMessage()    {}
func (*QueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{8}
}
func (m *QueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRequest.Merge(dst, src)
}
func (m *QueryRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *QueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRequest proto.InternalMessageInfo

type QueryResponse struct {
	// Response header. Set on the first QueryResponse only.
	Header *protocol.Header `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	// Encoded table rows.
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *QueryResponse) Reset()         { *m = QueryResponse{} }
func (m *QueryResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResponse) ProtoMessage()    {}
func (*QueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{9}
}
func (m *QueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResponse.Merge(dst, src)
}
func (m *QueryResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *QueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResponse proto.InternalMessageInfo

// SchemaSpec defines a set of Relations and their Mappings, Dimensions, Metrics,
// and MaterializedViews. The complete Schema must be referentially consistent:
// any Mapping, Dimension or Metric used in a Relation or MaterializedView must
// be defined. Similarly, Dimensions referenced from Metrics must be defined,
// and of the proper associated type.
type SchemaSpec struct {
	Mappings   []MappingSpec          `protobuf:"bytes,1,rep,name=mappings" json:"mappings"`
	Dimensions []DimensionSpec        `protobuf:"bytes,2,rep,name=dimensions" json:"dimensions"`
	Metrics    []MetricSpec           `protobuf:"bytes,3,rep,name=metrics" json:"metrics"`
	Relations  []RelationSpec         `protobuf:"bytes,4,rep,name=relations" json:"relations"`
	Views      []MaterializedViewSpec `protobuf:"bytes,5,rep,name=views" json:"views"`
}

func (m *SchemaSpec) Reset()         { *m = SchemaSpec{} }
func (m *SchemaSpec) String() string { return proto.CompactTextString(m) }
func (*SchemaSpec) ProtoMessage()    {}
func (*SchemaSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{10}
}
func (m *SchemaSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SchemaSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaSpec.Merge(dst, src)
}
func (m *SchemaSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SchemaSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaSpec proto.InternalMessageInfo

// GetSchemaResponse is the response of the GetSchema RPC.
type GetSchemaResponse struct {
	// Name of this Factable release instance.
	Instance string `protobuf:"bytes,3,opt,name=instance,proto3" json:"instance,omitempty"`
	// ModRevision of the current SchemaSpec
	ModRevision int64 `protobuf:"varint,1,opt,name=mod_revision,json=modRevision,proto3" json:"mod_revision,omitempty"`
	// Current value of the SchemaSpec. Zero-valued if |mod_revision| is zero.
	Spec SchemaSpec `protobuf:"bytes,2,opt,name=spec" json:"spec"`
	// LabelSelector over Extractor output / VTable input "delta" partitions.
	DeltaPartitions protocol.LabelSelector `protobuf:"bytes,4,opt,name=delta_partitions,json=deltaPartitions" json:"delta_partitions"`
}

func (m *GetSchemaResponse) Reset()         { *m = GetSchemaResponse{} }
func (m *GetSchemaResponse) String() string { return proto.CompactTextString(m) }
func (*GetSchemaResponse) ProtoMessage()    {}
func (*GetSchemaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{11}
}
func (m *GetSchemaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSchemaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSchemaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetSchemaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSchemaResponse.Merge(dst, src)
}
func (m *GetSchemaResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetSchemaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSchemaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSchemaResponse proto.InternalMessageInfo

// UpdateSchemaRequest is the request of the UpdateSchema RPC.
type UpdateSchemaRequest struct {
	// Expected Name of the Factable release instance.
	ExpectInstance string `protobuf:"bytes,1,opt,name=expect_instance,json=expectInstance,proto3" json:"expect_instance,omitempty"`
	// Expected ModRevision of the current SchemaSpec. Zero if the SchemaSpec
	// is being created for the first time.
	ExpectModRevision int64 `protobuf:"varint,2,opt,name=expect_mod_revision,json=expectModRevision,proto3" json:"expect_mod_revision,omitempty"`
	// Updated SchemaSpec to apply.
	Update SchemaSpec `protobuf:"bytes,3,opt,name=update" json:"update"`
}

func (m *UpdateSchemaRequest) Reset()         { *m = UpdateSchemaRequest{} }
func (m *UpdateSchemaRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateSchemaRequest) ProtoMessage()    {}
func (*UpdateSchemaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_factable_69e4e239ea5e269c, []int{12}
}
func (m *UpdateSchemaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSchemaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateSchemaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateSchemaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSchemaRequest.Merge(dst, src)
}
func (m *UpdateSchemaRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UpdateSchemaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSchemaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSchemaRequest proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MappingSpec)(nil), "factable.MappingSpec")
	proto.RegisterType((*DimensionSpec)(nil), "factable.DimensionSpec")
	proto.RegisterType((*MetricSpec)(nil), "factable.MetricSpec")
	proto.RegisterType((*RelationSpec)(nil), "factable.RelationSpec")
	proto.RegisterType((*ViewSpec)(nil), "factable.ViewSpec")
	proto.RegisterType((*MaterializedViewSpec)(nil), "factable.MaterializedViewSpec")
	proto.RegisterType((*MaterializedViewSpec_Retention)(nil), "factable.MaterializedViewSpec.Retention")
	proto.RegisterType((*QuerySpec)(nil), "factable.QuerySpec")
	proto.RegisterType((*QuerySpec_Filter)(nil), "factable.QuerySpec.Filter")
	proto.RegisterType((*Range)(nil), "factable.Range")
	proto.RegisterType((*Range_Int)(nil), "factable.Range.Int")
	proto.RegisterType((*Range_Float)(nil), "factable.Range.Float")
	proto.RegisterType((*Range_String)(nil), "factable.Range.String")
	proto.RegisterType((*Range_Time)(nil), "factable.Range.Time")
	proto.RegisterType((*QueryRequest)(nil), "factable.QueryRequest")
	proto.RegisterType((*QueryResponse)(nil), "factable.QueryResponse")
	proto.RegisterType((*SchemaSpec)(nil), "factable.SchemaSpec")
	proto.RegisterType((*GetSchemaResponse)(nil), "factable.GetSchemaResponse")
	proto.RegisterType((*UpdateSchemaRequest)(nil), "factable.UpdateSchemaRequest")
	proto.RegisterEnum("factable.DimensionType", DimensionType_name, DimensionType_value)
	proto.RegisterEnum("factable.MetricType", MetricType_name, MetricType_value)
}
func (this *ViewSpec) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ViewSpec)
	if !ok {
		that2, ok := that.(ViewSpec)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ViewSpec")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ViewSpec but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ViewSpec but is not nil && this == nil")
	}
	if this.RelTag != that1.RelTag {
		return fmt.Errorf("RelTag this(%v) Not Equal that(%v)", this.RelTag, that1.RelTag)
	}
	if len(this.Dimensions) != len(that1.Dimensions) {
		return fmt.Errorf("Dimensions this(%v) Not Equal that(%v)", len(this.Dimensions), len(that1.Dimensions))
	}
	for i := range this.Dimensions {
		if this.Dimensions[i] != that1.Dimensions[i] {
			return fmt.Errorf("Dimensions this[%v](%v) Not Equal that[%v](%v)", i, this.Dimensions[i], i, that1.Dimensions[i])
		}
	}
	if len(this.Metrics) != len(that1.Metrics) {
		return fmt.Errorf("Metrics this(%v) Not Equal that(%v)", len(this.Metrics), len(that1.Metrics))
	}
	for i := range this.Metrics {
		if this.Metrics[i] != that1.Metrics[i] {
			return fmt.Errorf("Metrics this[%v](%v) Not Equal that[%v](%v)", i, this.Metrics[i], i, that1.Metrics[i])
		}
	}
	return nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SchemaClient is the client API for Schema service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SchemaClient interface {
	// GetSchema retrieves the current SchemaSpec.
	GetSchema(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetSchemaResponse, error)
	// UpdateSchema updates the SchemaSpec to a new value.
	UpdateSchema(ctx context.Context, in *UpdateSchemaRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type schemaClient struct {
	cc *grpc.ClientConn
}

func NewSchemaClient(cc *grpc.ClientConn) SchemaClient {
	return &schemaClient{cc}
}

func (c *schemaClient) GetSchema(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetSchemaResponse, error) {
	out := new(GetSchemaResponse)
	err := c.cc.Invoke(ctx, "/factable.Schema/GetSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaClient) UpdateSchema(ctx context.Context, in *UpdateSchemaRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/factable.Schema/UpdateSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SchemaServer is the server API for Schema service.
type SchemaServer interface {
	// GetSchema retrieves the current SchemaSpec.
	GetSchema(context.Context, *empty.Empty) (*GetSchemaResponse, error)
	// UpdateSchema updates the SchemaSpec to a new value.
	UpdateSchema(context.Context, *UpdateSchemaRequest) (*empty.Empty, error)
}

func RegisterSchemaServer(s *grpc.Server, srv SchemaServer) {
	s.RegisterService(&_Schema_serviceDesc, srv)
}

func _Schema_GetSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaServer).GetSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/factable.Schema/GetSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaServer).GetSchema(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schema_UpdateSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaServer).UpdateSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/factable.Schema/UpdateSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaServer).UpdateSchema(ctx, req.(*UpdateSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Schema_serviceDesc = grpc.ServiceDesc{
	ServiceName: "factable.Schema",
	HandlerType: (*SchemaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSchema",
			Handler:    _Schema_GetSchema_Handler,
		},
		{
			MethodName: "UpdateSchema",
			Handler:    _Schema_UpdateSchema_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "factable.proto",
}

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (Query_QueryClient, error)
}

type queryClient struct {
	cc *grpc.ClientConn
}

func NewQueryClient(cc *grpc.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (Query_QueryClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Query_serviceDesc.Streams[0], "/factable.Query/Query", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryQueryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_QueryClient interface {
	Recv() (*QueryResponse, error)
	grpc.ClientStream
}

type queryQueryClient struct {
	grpc.ClientStream
}

func (x *queryQueryClient) Recv() (*QueryResponse, error) {
	m := new(QueryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	Query(*QueryRequest, Query_QueryServer) error
}

func RegisterQueryServer(s *grpc.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Query_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).Query(m, &queryQueryServer{stream})
}

type Query_QueryServer interface {
	Send(*QueryResponse) error
	grpc.ServerStream
}

type queryQueryServer struct {
	grpc.ServerStream
}

func (x *queryQueryServer) Send(m *QueryResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "factable.Query",
	HandlerType: (*QueryServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Query",
			Handler:       _Query_Query_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "factable.proto",
}

func (m *MappingSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Tag))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	return i, nil
}

func (m *DimensionSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DimensionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Tag))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	return i, nil
}

func (m *MetricSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Tag))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Type))
	}
	if m.DimTag != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.DimTag))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	return i, nil
}

func (m *RelationSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Tag))
	}
	if m.Mapping != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Mapping))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintFactable(dAtA, i, uint64(m.Selector.ProtoSize()))
	n1, err := m.Selector.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Dimensions) > 0 {
		dAtA3 := make([]byte, len(m.Dimensions)*10)
		var j2 int
		for _, num1 := range m.Dimensions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintFactable(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	return i, nil
}

func (m *ViewSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RelTag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.RelTag))
	}
	if len(m.Dimensions) > 0 {
		dAtA5 := make([]byte, len(m.Dimensions)*10)
		var j4 int
		for _, num1 := range m.Dimensions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintFactable(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.Metrics) > 0 {
		dAtA7 := make([]byte, len(m.Metrics)*10)
		var j6 int
		for _, num1 := range m.Metrics {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFactable(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	return i, nil
}

func (m *MaterializedViewSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterializedViewSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Tag))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintFactable(dAtA, i, uint64(m.View.ProtoSize()))
	n8, err := m.View.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.Retention != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Retention.ProtoSize()))
		n9, err := m.Retention.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *MaterializedViewSpec_Retention) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterializedViewSpec_Retention) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintFactable(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.RemoveAfter)))
	n10, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.RemoveAfter, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if m.RelativeTo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.RelativeTo))
	}
	return i, nil
}

func (m *QuerySpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintFactable(dAtA, i, uint64(m.View.ProtoSize()))
	n11, err := m.View.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if len(m.Filters) > 0 {
		for _, msg := range m.Filters {
			dAtA[i] = 0x12
			i++
			i = encodeVarintFactable(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QuerySpec_Filter) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpec_Filter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dimension != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Dimension))
	}
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintFactable(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Int != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Int.ProtoSize()))
		n12, err := m.Int.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Float != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Float.ProtoSize()))
		n13, err := m.Float.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Str != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Str.ProtoSize()))
		n14, err := m.Str.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Time != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Time.ProtoSize()))
		n15, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *Range_Int) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range_Int) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Begin != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Begin))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.End))
	}
	return i, nil
}

func (m *Range_Float) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range_Float) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Begin != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Begin))))
		i += 8
	}
	if m.End != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.End))))
		i += 8
	}
	return i, nil
}

func (m *Range_String) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range_String) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Begin) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Begin)))
		i += copy(dAtA[i:], m.Begin)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	return i, nil
}

func (m *Range_Time) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range_Time) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintFactable(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.Begin)))
	n16, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Begin, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	dAtA[i] = 0x12
	i++
	i = encodeVarintFactable(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.End)))
	n17, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.End, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	return i, nil
}

func (m *QueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Header.ProtoSize()))
		n18, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.View))
	}
	if len(m.Shard) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Shard)))
		i += copy(dAtA[i:], m.Shard)
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintFactable(dAtA, i, uint64(m.Query.ProtoSize()))
	n19, err := m.Query.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	return i, nil
}

func (m *QueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.Header.ProtoSize()))
		n20, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *SchemaSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mappings) > 0 {
		for _, msg := range m.Mappings {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFactable(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Dimensions) > 0 {
		for _, msg := range m.Dimensions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintFactable(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Metrics) > 0 {
		for _, msg := range m.Metrics {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintFactable(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Relations) > 0 {
		for _, msg := range m.Relations {
			dAtA[i] = 0x22
			i++
			i = encodeVarintFactable(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Views) > 0 {
		for _, msg := range m.Views {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintFactable(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetSchemaResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSchemaResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ModRevision != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.ModRevision))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintFactable(dAtA, i, uint64(m.Spec.ProtoSize()))
	n21, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	if len(m.Instance) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintFactable(dAtA, i, uint64(m.DeltaPartitions.ProtoSize()))
	n22, err := m.DeltaPartitions.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	return i, nil
}

func (m *UpdateSchemaRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSchemaRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExpectInstance) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFactable(dAtA, i, uint64(len(m.ExpectInstance)))
		i += copy(dAtA[i:], m.ExpectInstance)
	}
	if m.ExpectModRevision != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFactable(dAtA, i, uint64(m.ExpectModRevision))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintFactable(dAtA, i, uint64(m.Update.ProtoSize()))
	n23, err := m.Update.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	return i, nil
}

func encodeVarintFactable(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MappingSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovFactable(uint64(m.Tag))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	return n
}

func (m *DimensionSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovFactable(uint64(m.Tag))
	}
	if m.Type != 0 {
		n += 1 + sovFactable(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	return n
}

func (m *MetricSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovFactable(uint64(m.Tag))
	}
	if m.Type != 0 {
		n += 1 + sovFactable(uint64(m.Type))
	}
	if m.DimTag != 0 {
		n += 1 + sovFactable(uint64(m.DimTag))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	return n
}

func (m *RelationSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovFactable(uint64(m.Tag))
	}
	if m.Mapping != 0 {
		n += 1 + sovFactable(uint64(m.Mapping))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = m.Selector.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	if len(m.Dimensions) > 0 {
		l = 0
		for _, e := range m.Dimensions {
			l += sovFactable(uint64(e))
		}
		n += 1 + sovFactable(uint64(l)) + l
	}
	return n
}

func (m *ViewSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RelTag != 0 {
		n += 1 + sovFactable(uint64(m.RelTag))
	}
	if len(m.Dimensions) > 0 {
		l = 0
		for _, e := range m.Dimensions {
			l += sovFactable(uint64(e))
		}
		n += 1 + sovFactable(uint64(l)) + l
	}
	if len(m.Metrics) > 0 {
		l = 0
		for _, e := range m.Metrics {
			l += sovFactable(uint64(e))
		}
		n += 1 + sovFactable(uint64(l)) + l
	}
	return n
}

func (m *MaterializedViewSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovFactable(uint64(m.Tag))
	}
	l = m.View.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.Retention != nil {
		l = m.Retention.ProtoSize()
		n += 1 + l + sovFactable(uint64(l))
	}
	return n
}

func (m *MaterializedViewSpec_Retention) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.RemoveAfter)
	n += 1 + l + sovFactable(uint64(l))
	if m.RelativeTo != 0 {
		n += 1 + sovFactable(uint64(m.RelativeTo))
	}
	return n
}

func (m *QuerySpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.View.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	return n
}

func (m *QuerySpec_Filter) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dimension != 0 {
		n += 1 + sovFactable(uint64(m.Dimension))
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	return n
}

func (m *Range) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Int != nil {
		l = m.Int.ProtoSize()
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.Float != nil {
		l = m.Float.ProtoSize()
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.Str != nil {
		l = m.Str.ProtoSize()
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.Time != nil {
		l = m.Time.ProtoSize()
		n += 1 + l + sovFactable(uint64(l))
	}
	return n
}

func (m *Range_Int) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != 0 {
		n += 1 + sovFactable(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovFactable(uint64(m.End))
	}
	return n
}

func (m *Range_Float) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != 0 {
		n += 9
	}
	if m.End != 0 {
		n += 9
	}
	return n
}

func (m *Range_String) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Begin)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	return n
}

func (m *Range_Time) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Begin)
	n += 1 + l + sovFactable(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.End)
	n += 1 + l + sovFactable(uint64(l))
	return n
}

func (m *QueryRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.View != 0 {
		n += 1 + sovFactable(uint64(m.View))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = m.Query.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	return n
}

func (m *QueryResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovFactable(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	return n
}

func (m *SchemaSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Mappings) > 0 {
		for _, e := range m.Mappings {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	if len(m.Dimensions) > 0 {
		for _, e := range m.Dimensions {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	if len(m.Relations) > 0 {
		for _, e := range m.Relations {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	if len(m.Views) > 0 {
		for _, e := range m.Views {
			l = e.ProtoSize()
			n += 1 + l + sovFactable(uint64(l))
		}
	}
	return n
}

func (m *GetSchemaResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ModRevision != 0 {
		n += 1 + sovFactable(uint64(m.ModRevision))
	}
	l = m.Spec.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	l = m.DeltaPartitions.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	return n
}

func (m *UpdateSchemaRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExpectInstance)
	if l > 0 {
		n += 1 + l + sovFactable(uint64(l))
	}
	if m.ExpectModRevision != 0 {
		n += 1 + sovFactable(uint64(m.ExpectModRevision))
	}
	l = m.Update.ProtoSize()
	n += 1 + l + sovFactable(uint64(l))
	return n
}

func sovFactable(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFactable(x uint64) (n int) {
	return sovFactable(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MappingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= (MapTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DimensionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DimensionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DimensionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= (DimTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (DimensionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= (MetTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MetricType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DimTag", wireType)
			}
			m.DimTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DimTag |= (DimTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= (RelTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mapping", wireType)
			}
			m.Mapping = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mapping |= (MapTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v DimTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFactable
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (DimTag(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dimensions = append(m.Dimensions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFactable
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFactable
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Dimensions) == 0 {
					m.Dimensions = make([]DimTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v DimTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFactable
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (DimTag(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dimensions = append(m.Dimensions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimensions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelTag", wireType)
			}
			m.RelTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelTag |= (RelTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v DimTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFactable
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (DimTag(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dimensions = append(m.Dimensions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFactable
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFactable
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Dimensions) == 0 {
					m.Dimensions = make([]DimTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v DimTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFactable
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (DimTag(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dimensions = append(m.Dimensions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimensions", wireType)
			}
		case 3:
			if wireType == 0 {
				var v MetTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFactable
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (MetTag(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Metrics = append(m.Metrics, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFactable
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFactable
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Metrics) == 0 {
					m.Metrics = make([]MetTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v MetTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFactable
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (MetTag(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Metrics = append(m.Metrics, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterializedViewSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaterializedViewSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaterializedViewSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= (MVTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.View.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retention", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Retention == nil {
				m.Retention = &MaterializedViewSpec_Retention{}
			}
			if err := m.Retention.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterializedViewSpec_Retention) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Retention: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Retention: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.RemoveAfter, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeTo", wireType)
			}
			m.RelativeTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelativeTo |= (DimTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.View.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, QuerySpec_Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpec_Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimension", wireType)
			}
			m.Dimension = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dimension |= (DimTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, Range{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Int == nil {
				m.Int = &Range_Int{}
			}
			if err := m.Int.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Float == nil {
				m.Float = &Range_Float{}
			}
			if err := m.Float.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Str == nil {
				m.Str = &Range_String{}
			}
			if err := m.Str.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &Range_Time{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range_Int) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range_Float) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Float: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Float: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Begin = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.End = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range_String) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: String: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: String: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Begin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range_Time) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Time: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Time: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Begin, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.End, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &protocol.Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= (MVTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = github_com_LiveRamp_gazette_v2_pkg_consumer.ShardID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &protocol.Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mappings = append(m.Mappings, MappingSpec{})
			if err := m.Mappings[len(m.Mappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dimensions = append(m.Dimensions, DimensionSpec{})
			if err := m.Dimensions[len(m.Dimensions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, MetricSpec{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relations = append(m.Relations, RelationSpec{})
			if err := m.Relations[len(m.Relations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Views", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Views = append(m.Views, MaterializedViewSpec{})
			if err := m.Views[len(m.Views)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSchemaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSchemaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSchemaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModRevision", wireType)
			}
			m.ModRevision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModRevision |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaPartitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeltaPartitions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSchemaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSchemaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSchemaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectInstance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectInstance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectModRevision", wireType)
			}
			m.ExpectModRevision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectModRevision |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFactable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Update.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFactable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFactable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFactable(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFactable
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFactable
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFactable
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFactable
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFactable(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFactable = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFactable   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("factable.proto", fileDescriptor_factable_69e4e239ea5e269c) }

var fileDescriptor_factable_69e4e239ea5e269c = []byte{
	// 1388 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x4b, 0x6f, 0xdb, 0x46,
	0x10, 0x36, 0x4d, 0x49, 0xb6, 0x46, 0x8a, 0xc3, 0xac, 0x9d, 0x58, 0x55, 0x12, 0x29, 0x55, 0x5a,
	0xd4, 0x48, 0x1a, 0x2a, 0x50, 0x8a, 0x06, 0x35, 0x50, 0xa0, 0x76, 0xfc, 0x88, 0x00, 0x2b, 0x4d,
	0x29, 0xc5, 0x45, 0x4f, 0x02, 0x4d, 0xae, 0x69, 0xa2, 0xe2, 0x23, 0xe4, 0xca, 0xa9, 0x73, 0x2a,
	0x7a, 0xe9, 0x35, 0xbd, 0xf5, 0x98, 0xf6, 0x27, 0xf4, 0xde, 0x7b, 0x0e, 0x3d, 0xe4, 0x50, 0xa0,
	0x39, 0xb9, 0x48, 0xfc, 0x2f, 0x72, 0x2a, 0xf6, 0x45, 0x52, 0xb2, 0x6c, 0xa8, 0x27, 0xee, 0xee,
	0x7c, 0xdf, 0xec, 0xec, 0xcc, 0xec, 0xb7, 0x84, 0x85, 0x7d, 0xd3, 0x22, 0xe6, 0xde, 0x00, 0xeb,
	0x61, 0x14, 0x90, 0x00, 0xcd, 0xcb, 0x79, 0xf5, 0x8e, 0xe3, 0x92, 0x83, 0xe1, 0x9e, 0x6e, 0x05,
	0x5e, 0xd3, 0x09, 0x9c, 0xa0, 0xc9, 0x00, 0x7b, 0xc3, 0x7d, 0x36, 0x63, 0x13, 0x36, 0xe2, 0xc4,
	0xea, 0x6a, 0x06, 0xbe, 0xe3, 0x1e, 0x62, 0xc3, 0xf4, 0xc2, 0xa6, 0x63, 0x3e, 0xc7, 0x84, 0xe0,
	0xe6, 0x61, 0xab, 0x19, 0x7e, 0xef, 0x70, 0x0f, 0x56, 0x30, 0x48, 0x06, 0x82, 0x5b, 0x73, 0x82,
	0xc0, 0x19, 0xe0, 0x74, 0x07, 0x7b, 0x18, 0x99, 0xc4, 0x0d, 0x7c, 0x61, 0xaf, 0x8f, 0xdb, 0x89,
	0xeb, 0xe1, 0x98, 0x98, 0x5e, 0x28, 0x00, 0x57, 0xc7, 0x01, 0xd8, 0x0b, 0xc9, 0x11, 0x37, 0x36,
	0xba, 0x50, 0xea, 0x98, 0x61, 0xe8, 0xfa, 0x4e, 0x37, 0xc4, 0x16, 0xba, 0x06, 0x2a, 0x31, 0x9d,
	0x8a, 0x72, 0x43, 0x59, 0x51, 0xd7, 0xe1, 0xfd, 0x71, 0xbd, 0xd0, 0x31, 0xc3, 0x9e, 0xe9, 0x18,
	0x74, 0x19, 0x21, 0xc8, 0xf9, 0xa6, 0x87, 0x2b, 0xb3, 0x37, 0x94, 0x95, 0xa2, 0xc1, 0xc6, 0x74,
	0xcd, 0xc6, 0xb1, 0x55, 0x51, 0xf9, 0x1a, 0x1d, 0x37, 0x7e, 0x52, 0xe0, 0xc2, 0x86, 0xeb, 0x61,
	0x3f, 0x76, 0x03, 0xff, 0x0c, 0xbf, 0x1b, 0xae, 0x97, 0xf8, 0xbd, 0x0d, 0x39, 0x72, 0x14, 0x72,
	0xbf, 0x0b, 0xad, 0x65, 0x3d, 0x49, 0x7b, 0xe2, 0xa4, 0x77, 0x14, 0x62, 0x83, 0x81, 0x92, 0x20,
	0xd4, 0x09, 0x41, 0xe4, 0x32, 0x41, 0xfc, 0xa6, 0x00, 0x74, 0x30, 0x89, 0x5c, 0xeb, 0xac, 0x93,
	0x61, 0x92, 0x44, 0xb0, 0x32, 0x12, 0xc1, 0x52, 0x1a, 0x01, 0xf7, 0x90, 0xd9, 0xfe, 0x26, 0xcc,
	0xd9, 0xae, 0xd7, 0xa7, 0xbe, 0xd4, 0x53, 0xa7, 0x29, 0xd8, 0xec, 0x9b, 0xc4, 0x98, 0x9b, 0x10,
	0x63, 0x3e, 0x13, 0xe3, 0x5b, 0x05, 0xca, 0x06, 0x1e, 0xb0, 0x72, 0x9e, 0x11, 0xa5, 0x81, 0x07,
	0x49, 0x94, 0x1f, 0xc1, 0x9c, 0xc7, 0x8b, 0xc5, 0x02, 0x1d, 0xad, 0x90, 0x34, 0x4d, 0x9b, 0x20,
	0xf4, 0x05, 0xcc, 0xc7, 0x78, 0x80, 0x2d, 0x12, 0x44, 0x2c, 0xa8, 0x52, 0x6b, 0x59, 0x4f, 0x7a,
	0x6f, 0xc7, 0xdc, 0xc3, 0x83, 0xae, 0x30, 0xaf, 0xe7, 0x5e, 0x1d, 0xd7, 0x67, 0x8c, 0x04, 0x8e,
	0x6e, 0x01, 0xd8, 0xb2, 0x34, 0x71, 0xa5, 0x70, 0x43, 0x1d, 0xcb, 0x43, 0xc6, 0xda, 0xf8, 0x59,
	0x81, 0xf9, 0x5d, 0x17, 0x3f, 0x63, 0xe7, 0xbb, 0x09, 0x73, 0x11, 0x1e, 0xf4, 0x27, 0x9f, 0xb1,
	0x10, 0xb1, 0xef, 0x98, 0xf7, 0xd9, 0xf3, 0xbc, 0xb3, 0x94, 0xb0, 0x12, 0xc5, 0x15, 0x35, 0x05,
	0x8a, 0xd2, 0x4a, 0xd3, 0x6a, 0xee, 0xe5, 0xcb, 0xba, 0xd2, 0xf8, 0x7b, 0x16, 0x96, 0x3a, 0x26,
	0xc1, 0x91, 0x6b, 0x0e, 0xdc, 0xe7, 0xd8, 0x4e, 0xa2, 0xba, 0x9a, 0xcd, 0x7a, 0xf1, 0xfd, 0x71,
	0x3d, 0xdf, 0xd9, 0x4d, 0x92, 0xfe, 0x29, 0xe4, 0x0e, 0x5d, 0xfc, 0x8c, 0x65, 0xbc, 0xd4, 0x42,
	0x69, 0x6b, 0x48, 0xba, 0xc8, 0x0e, 0x43, 0x4d, 0x9d, 0xfc, 0x2d, 0x28, 0x46, 0x98, 0x60, 0x9f,
	0x56, 0x5e, 0x64, 0x7f, 0x25, 0xd3, 0x75, 0x13, 0xa2, 0xd4, 0x0d, 0x89, 0x37, 0x52, 0x6a, 0xf5,
	0x47, 0x05, 0x8a, 0x89, 0x01, 0x6d, 0x41, 0x39, 0xc2, 0x5e, 0x70, 0x88, 0xfb, 0xe6, 0x3e, 0xc1,
	0x11, 0x3b, 0x51, 0xa9, 0xf5, 0x81, 0xce, 0x15, 0x40, 0x97, 0x0a, 0xa0, 0x6f, 0x08, 0x09, 0x59,
	0x9f, 0xa7, 0xa1, 0xff, 0xfa, 0x6f, 0x5d, 0x31, 0x4a, 0x9c, 0xb8, 0x46, 0x79, 0xe8, 0x36, 0x94,
	0x22, 0xd6, 0x96, 0x87, 0xb8, 0x4f, 0x82, 0x6c, 0xb3, 0xc9, 0x12, 0x48, 0x73, 0x2f, 0x68, 0xbc,
	0x51, 0xa0, 0xf8, 0xcd, 0x10, 0x47, 0x47, 0x2c, 0x97, 0x32, 0x5d, 0xca, 0x54, 0xe9, 0x5a, 0x85,
	0xb9, 0x7d, 0x77, 0x40, 0x70, 0xc4, 0xeb, 0x5c, 0x6a, 0x55, 0x53, 0x42, 0xe2, 0x53, 0xdf, 0x62,
	0x10, 0x41, 0x94, 0x84, 0xaa, 0x09, 0x05, 0x6e, 0x40, 0x2b, 0x50, 0x4c, 0x5a, 0x62, 0x82, 0xc6,
	0xa4, 0x46, 0x74, 0x07, 0x0a, 0x91, 0xe9, 0x3b, 0x58, 0x6e, 0x77, 0x31, 0xdd, 0xce, 0xa0, 0xeb,
	0x62, 0x0f, 0x01, 0x6a, 0xfc, 0xa9, 0x42, 0x9e, 0xad, 0xa3, 0x8f, 0x41, 0x75, 0x7d, 0x22, 0x4e,
	0xb5, 0x38, 0xc6, 0xd2, 0xdb, 0x3e, 0x31, 0xa8, 0x1d, 0xdd, 0x86, 0xfc, 0xfe, 0x20, 0x30, 0x89,
	0xe8, 0x96, 0xcb, 0xe3, 0xc0, 0x2d, 0x6a, 0x34, 0x38, 0x06, 0xad, 0x80, 0x1a, 0x93, 0x88, 0xb5,
	0x4a, 0xa9, 0x75, 0x65, 0x1c, 0xda, 0x25, 0x91, 0xeb, 0x3b, 0x06, 0x85, 0x30, 0x79, 0x72, 0x85,
	0x9e, 0x94, 0xb2, 0xf2, 0xc4, 0xa1, 0x3d, 0xd7, 0xa3, 0xf2, 0xe4, 0x7a, 0xb8, 0x7a, 0x07, 0xd4,
	0xb6, 0x4f, 0xd0, 0x12, 0xe4, 0xf7, 0xb0, 0xe3, 0x8a, 0x6c, 0x18, 0x7c, 0x82, 0x34, 0x50, 0xb1,
	0x6f, 0xf3, 0x72, 0x1a, 0x74, 0x58, 0x6d, 0x42, 0x9e, 0x85, 0x34, 0x4a, 0x50, 0x26, 0x10, 0x14,
	0x4e, 0xb8, 0x0b, 0x05, 0x1e, 0xd8, 0x28, 0xa3, 0x38, 0x81, 0x51, 0xe4, 0x8c, 0xe7, 0x90, 0xa3,
	0xf1, 0xa1, 0xd5, 0x2c, 0x9e, 0x16, 0x7a, 0xbc, 0x29, 0x7b, 0xf2, 0xdd, 0xe2, 0x5d, 0xf9, 0x82,
	0x76, 0xa5, 0xf0, 0xfa, 0x79, 0xea, 0x75, 0x5a, 0x26, 0x25, 0x34, 0xfe, 0x51, 0xa0, 0xcc, 0xda,
	0xc8, 0xc0, 0x4f, 0x87, 0x38, 0xa6, 0x29, 0x2f, 0x1c, 0x60, 0xd3, 0x4e, 0xae, 0x86, 0x96, 0x2a,
	0xde, 0x43, 0xb6, 0x6e, 0x08, 0x3b, 0xba, 0x9e, 0xb9, 0xf6, 0x23, 0xa2, 0xc0, 0x1b, 0xb7, 0x03,
	0xf9, 0xf8, 0xc0, 0x8c, 0x6c, 0x7e, 0xd1, 0xd7, 0xef, 0xbf, 0x3f, 0xae, 0xdf, 0x9b, 0xe2, 0x91,
	0xb7, 0x02, 0x3f, 0x1e, 0x7a, 0x38, 0xd2, 0xbb, 0x94, 0xdc, 0xde, 0x30, 0xb8, 0x17, 0xd4, 0x84,
	0xfc, 0x53, 0x1a, 0xa7, 0xa8, 0xf0, 0xe2, 0x84, 0x5b, 0x20, 0x5a, 0x93, 0xe3, 0x1a, 0x5d, 0xb8,
	0x20, 0x0e, 0x16, 0x87, 0x81, 0x1f, 0xe3, 0xff, 0x71, 0xb2, 0x0a, 0xcc, 0x59, 0x81, 0x4f, 0x25,
	0x83, 0x1d, 0xae, 0x6c, 0xc8, 0x69, 0xe3, 0x8f, 0x59, 0x80, 0xae, 0x75, 0x80, 0x3d, 0x93, 0x5d,
	0xe5, 0xfb, 0x30, 0x2f, 0xde, 0x94, 0xb8, 0xa2, 0xb0, 0xeb, 0x72, 0x39, 0x2b, 0x51, 0xc9, 0x5f,
	0x83, 0x7c, 0x1e, 0x24, 0x18, 0x7d, 0x79, 0x4a, 0xc0, 0x4b, 0x13, 0x5f, 0xf5, 0x0c, 0x39, 0xab,
	0xe9, 0x9f, 0x8d, 0x6a, 0x7a, 0xe9, 0xf4, 0x7b, 0x9c, 0x21, 0x4a, 0x28, 0x5a, 0xa5, 0x8a, 0xca,
	0x9f, 0xd2, 0xb8, 0x92, 0x63, 0xbc, 0xec, 0x9d, 0xca, 0xbc, 0xb2, 0x82, 0x99, 0xc2, 0x69, 0x6f,
	0xd2, 0xaa, 0xc6, 0x95, 0x3c, 0xe3, 0xd5, 0xce, 0x57, 0x62, 0x59, 0x09, 0x46, 0x69, 0xfc, 0xa5,
	0xc0, 0xa5, 0x6d, 0x4c, 0x78, 0xde, 0x92, 0x72, 0x7c, 0x08, 0x65, 0x2f, 0xb0, 0xfb, 0x11, 0x3e,
	0x74, 0x53, 0x55, 0x32, 0x4a, 0x5e, 0x60, 0x1b, 0x62, 0x09, 0xe9, 0x90, 0x8b, 0x43, 0x6c, 0x89,
	0xae, 0xce, 0x9c, 0x31, 0x2d, 0x81, 0xd4, 0x4a, 0x8a, 0x43, 0x55, 0x98, 0x77, 0xfd, 0x98, 0x98,
	0xbe, 0x25, 0x9f, 0x97, 0x64, 0x8e, 0x1e, 0x82, 0x66, 0xe3, 0x01, 0x31, 0xfb, 0xa1, 0x19, 0x11,
	0x57, 0xe6, 0x60, 0x8a, 0x37, 0xfd, 0x22, 0xa3, 0x3d, 0x4e, 0x58, 0x8d, 0xdf, 0x15, 0x58, 0x7c,
	0x12, 0xda, 0x26, 0xc1, 0xf2, 0x44, 0xfc, 0xe6, 0x7c, 0x02, 0x17, 0xf1, 0x0f, 0x21, 0xb6, 0x48,
	0x3f, 0x09, 0x82, 0x5f, 0xfc, 0x05, 0xbe, 0xdc, 0x96, 0xa1, 0xe8, 0xb0, 0x28, 0x80, 0x23, 0x09,
	0xe0, 0xa2, 0x73, 0x89, 0x9b, 0x3a, 0x99, 0x34, 0xb4, 0xa0, 0x30, 0x64, 0xfb, 0x09, 0x21, 0x3c,
	0x2f, 0x11, 0x02, 0x79, 0xeb, 0xdb, 0xcc, 0xff, 0x25, 0xfd, 0x37, 0x43, 0x4b, 0xa0, 0xb5, 0x1f,
	0xed, 0xae, 0xed, 0xb4, 0x37, 0xfa, 0x1b, 0xed, 0x4e, 0xbf, 0xf7, 0xdd, 0xe3, 0x4d, 0x6d, 0x06,
	0x01, 0x14, 0x76, 0xd7, 0x8c, 0xf6, 0xa3, 0x9e, 0xa6, 0xa0, 0x22, 0xe4, 0xb7, 0x76, 0xbe, 0x5e,
	0xeb, 0x69, 0x2a, 0x5d, 0xee, 0xf6, 0x8c, 0xf6, 0xa3, 0x6d, 0x2d, 0x87, 0x2e, 0x40, 0xb1, 0xd7,
	0xee, 0x6c, 0x76, 0x7b, 0x6b, 0x9d, 0xc7, 0x5a, 0xfe, 0xd6, 0xbe, 0xfc, 0x67, 0x64, 0x5e, 0x97,
	0x61, 0x51, 0x7a, 0xed, 0x6c, 0xf6, 0x8c, 0xf6, 0x03, 0xe9, 0x78, 0x01, 0x80, 0x3b, 0xee, 0x77,
	0x9f, 0x74, 0x34, 0x05, 0x69, 0x50, 0x16, 0xf3, 0xed, 0x27, 0x6b, 0xdb, 0x9b, 0xda, 0x2c, 0xf5,
	0xcb, 0xb6, 0x63, 0x00, 0x95, 0x12, 0xf8, 0x96, 0xfd, 0x87, 0x3b, 0x3b, 0x5a, 0xae, 0xf5, 0x8b,
	0x02, 0x05, 0x7e, 0x3a, 0xf4, 0x15, 0x14, 0x93, 0xf6, 0x41, 0x57, 0x4e, 0x69, 0xdb, 0x26, 0xfd,
	0x59, 0xaf, 0x5e, 0x4d, 0x93, 0x72, 0xba, 0xd7, 0x36, 0xa1, 0x9c, 0xad, 0x18, 0xba, 0x9e, 0x82,
	0x27, 0x54, 0xb2, 0x7a, 0xc6, 0x1e, 0xad, 0x07, 0x90, 0x67, 0x92, 0x42, 0x6f, 0x03, 0x1f, 0x5c,
	0x19, 0x93, 0x21, 0xe9, 0x61, 0xf9, 0xd4, 0x3a, 0x8f, 0xe4, 0xae, 0xb2, 0x7e, 0xed, 0xd5, 0xdb,
	0xda, 0xcc, 0xab, 0x77, 0x35, 0xe5, 0xf5, 0xbb, 0x9a, 0xf2, 0xe2, 0xa4, 0x36, 0xf3, 0xf2, 0xa4,
	0xa6, 0xbc, 0x3e, 0xa9, 0xcd, 0xbc, 0x39, 0xa9, 0xcd, 0xec, 0x15, 0xd8, 0x96, 0xf7, 0xfe, 0x0b,
	0x00, 0x00, 0xff, 0xff, 0x94, 0x38, 0x2d, 0xb9, 0x59, 0x0d, 0x00, 0x00,
}
