// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: deltas.proto

package internal

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type DeltaEvent struct {
	// Extractor ID emitting the DeltaEvent. Often this will be a ShardID.
	// Backfill jobs use a unique and per-job ID.
	Extractor string `protobuf:"bytes,1,opt,name=extractor,proto3" json:"extractor,omitempty"`
	// Sequence number of the DeltaEvent, with respect to the |combiner|.
	// |seq_no| is monotonically increasing for row DeltaEvents. Commit
	// DeltaEvents use the |seq_no| of the last row DeltaEvent.
	SeqNo                int64    `protobuf:"varint,2,opt,name=seq_no,json=seqNo,proto3" json:"seq_no,omitempty"`
	RowKey               []byte   `protobuf:"bytes,3,opt,name=row_key,json=rowKey,proto3" json:"row_key,omitempty"`
	RowValue             []byte   `protobuf:"bytes,4,opt,name=row_value,json=rowValue,proto3" json:"row_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeltaEvent) Reset()         { *m = DeltaEvent{} }
func (m *DeltaEvent) String() string { return proto.CompactTextString(m) }
func (*DeltaEvent) ProtoMessage()    {}
func (*DeltaEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_deltas_e6414be59e31230f, []int{0}
}
func (m *DeltaEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeltaEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeltaEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DeltaEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeltaEvent.Merge(dst, src)
}
func (m *DeltaEvent) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeltaEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_DeltaEvent.DiscardUnknown(m)
}

var xxx_messageInfo_DeltaEvent proto.InternalMessageInfo

func (m *DeltaEvent) GetExtractor() string {
	if m != nil {
		return m.Extractor
	}
	return ""
}

func (m *DeltaEvent) GetSeqNo() int64 {
	if m != nil {
		return m.SeqNo
	}
	return 0
}

func (m *DeltaEvent) GetRowKey() []byte {
	if m != nil {
		return m.RowKey
	}
	return nil
}

func (m *DeltaEvent) GetRowValue() []byte {
	if m != nil {
		return m.RowValue
	}
	return nil
}

// Transactions manages per-extractor transactions of DeltaEvents.
type Transactions struct {
	// Extractor indexes states on Extractor ShardID.
	Extractor            map[string]Transactions_State `protobuf:"bytes,1,rep,name=extractor" json:"extractor" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Transactions) Reset()         { *m = Transactions{} }
func (m *Transactions) String() string { return proto.CompactTextString(m) }
func (*Transactions) ProtoMessage()    {}
func (*Transactions) Descriptor() ([]byte, []int) {
	return fileDescriptor_deltas_e6414be59e31230f, []int{1}
}
func (m *Transactions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transactions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transactions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Transactions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transactions.Merge(dst, src)
}
func (m *Transactions) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Transactions) XXX_DiscardUnknown() {
	xxx_messageInfo_Transactions.DiscardUnknown(m)
}

var xxx_messageInfo_Transactions proto.InternalMessageInfo

func (m *Transactions) GetExtractor() map[string]Transactions_State {
	if m != nil {
		return m.Extractor
	}
	return nil
}

// Transaction state of a single Extractor or back-fill loader.
type Transactions_State struct {
	Events               []DeltaEvent `protobuf:"bytes,1,rep,name=events" json:"events"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Transactions_State) Reset()         { *m = Transactions_State{} }
func (m *Transactions_State) String() string { return proto.CompactTextString(m) }
func (*Transactions_State) ProtoMessage()    {}
func (*Transactions_State) Descriptor() ([]byte, []int) {
	return fileDescriptor_deltas_e6414be59e31230f, []int{1, 0}
}
func (m *Transactions_State) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transactions_State) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transactions_State.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Transactions_State) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transactions_State.Merge(dst, src)
}
func (m *Transactions_State) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Transactions_State) XXX_DiscardUnknown() {
	xxx_messageInfo_Transactions_State.DiscardUnknown(m)
}

var xxx_messageInfo_Transactions_State proto.InternalMessageInfo

func (m *Transactions_State) GetEvents() []DeltaEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func init() {
	proto.RegisterType((*DeltaEvent)(nil), "internal.DeltaEvent")
	proto.RegisterType((*Transactions)(nil), "internal.Transactions")
	proto.RegisterMapType((map[string]Transactions_State)(nil), "internal.Transactions.ExtractorEntry")
	proto.RegisterType((*Transactions_State)(nil), "internal.Transactions.State")
}
func (m *DeltaEvent) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeltaEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Extractor) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDeltas(dAtA, i, uint64(len(m.Extractor)))
		i += copy(dAtA[i:], m.Extractor)
	}
	if m.SeqNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDeltas(dAtA, i, uint64(m.SeqNo))
	}
	if len(m.RowKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDeltas(dAtA, i, uint64(len(m.RowKey)))
		i += copy(dAtA[i:], m.RowKey)
	}
	if len(m.RowValue) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDeltas(dAtA, i, uint64(len(m.RowValue)))
		i += copy(dAtA[i:], m.RowValue)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Transactions) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transactions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Extractor) > 0 {
		for k, _ := range m.Extractor {
			dAtA[i] = 0xa
			i++
			v := m.Extractor[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).ProtoSize()
				msgSize += 1 + sovDeltas(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovDeltas(uint64(len(k))) + msgSize
			i = encodeVarintDeltas(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDeltas(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintDeltas(dAtA, i, uint64((&v).ProtoSize()))
			n1, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n1
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Transactions_State) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transactions_State) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDeltas(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintDeltas(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DeltaEvent) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Extractor)
	if l > 0 {
		n += 1 + l + sovDeltas(uint64(l))
	}
	if m.SeqNo != 0 {
		n += 1 + sovDeltas(uint64(m.SeqNo))
	}
	l = len(m.RowKey)
	if l > 0 {
		n += 1 + l + sovDeltas(uint64(l))
	}
	l = len(m.RowValue)
	if l > 0 {
		n += 1 + l + sovDeltas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transactions) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Extractor) > 0 {
		for k, v := range m.Extractor {
			_ = k
			_ = v
			l = v.ProtoSize()
			mapEntrySize := 1 + len(k) + sovDeltas(uint64(len(k))) + 1 + l + sovDeltas(uint64(l))
			n += mapEntrySize + 1 + sovDeltas(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transactions_State) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.ProtoSize()
			n += 1 + l + sovDeltas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDeltas(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDeltas(x uint64) (n int) {
	return sovDeltas(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DeltaEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeltas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extractor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeltas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeltas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extractor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNo", wireType)
			}
			m.SeqNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeltas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeltas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDeltas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RowKey = append(m.RowKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RowKey == nil {
				m.RowKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeltas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDeltas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RowValue = append(m.RowValue[:0], dAtA[iNdEx:postIndex]...)
			if m.RowValue == nil {
				m.RowValue = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeltas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDeltas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transactions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeltas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transactions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transactions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extractor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeltas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeltas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extractor == nil {
				m.Extractor = make(map[string]Transactions_State)
			}
			var mapkey string
			mapvalue := &Transactions_State{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDeltas
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDeltas
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDeltas
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDeltas
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthDeltas
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthDeltas
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Transactions_State{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDeltas(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDeltas
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Extractor[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeltas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDeltas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transactions_State) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeltas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: State: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: State: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeltas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeltas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, DeltaEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeltas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDeltas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDeltas(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDeltas
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDeltas
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDeltas
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDeltas
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDeltas
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDeltas(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDeltas = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDeltas   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("deltas.proto", fileDescriptor_deltas_e6414be59e31230f) }

var fileDescriptor_deltas_e6414be59e31230f = []byte{
	// 321 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x49, 0x49, 0xcd, 0x29,
	0x49, 0x2c, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0xc8, 0xcc, 0x2b, 0x49, 0x2d, 0xca,
	0x4b, 0xcc, 0x91, 0xd2, 0x4d, 0xcf, 0x2c, 0xc9, 0x28, 0x4d, 0xd2, 0x4b, 0xce, 0xcf, 0xd5, 0x4f,
	0xcf, 0x4f, 0xcf, 0xd7, 0x07, 0x2b, 0x48, 0x2a, 0x4d, 0x03, 0xf3, 0xc0, 0x1c, 0x30, 0x0b, 0xa2,
	0x51, 0xa9, 0x9c, 0x8b, 0xcb, 0x05, 0x64, 0x90, 0x6b, 0x59, 0x6a, 0x5e, 0x89, 0x90, 0x0c, 0x17,
	0x67, 0x6a, 0x45, 0x49, 0x51, 0x62, 0x72, 0x49, 0x7e, 0x91, 0x04, 0xa3, 0x02, 0xa3, 0x06, 0x67,
	0x10, 0x42, 0x40, 0x48, 0x94, 0x8b, 0xad, 0x38, 0xb5, 0x30, 0x3e, 0x2f, 0x5f, 0x82, 0x49, 0x81,
	0x51, 0x83, 0x39, 0x88, 0xb5, 0x38, 0xb5, 0xd0, 0x2f, 0x5f, 0x48, 0x9c, 0x8b, 0xbd, 0x28, 0xbf,
	0x3c, 0x3e, 0x3b, 0xb5, 0x52, 0x82, 0x59, 0x81, 0x51, 0x83, 0x27, 0x88, 0xad, 0x28, 0xbf, 0xdc,
	0x3b, 0xb5, 0x52, 0x48, 0x9a, 0x8b, 0x13, 0x24, 0x51, 0x96, 0x98, 0x53, 0x9a, 0x2a, 0xc1, 0x02,
	0x96, 0xe2, 0x28, 0xca, 0x2f, 0x0f, 0x03, 0xf1, 0x95, 0x3e, 0x31, 0x72, 0xf1, 0x84, 0x14, 0x25,
	0xe6, 0x15, 0x27, 0x26, 0x97, 0x64, 0xe6, 0xe7, 0x15, 0x0b, 0x79, 0xa2, 0xda, 0xcd, 0xac, 0xc1,
	0x6d, 0xa4, 0xaa, 0x07, 0xf3, 0x96, 0x1e, 0xb2, 0x52, 0x3d, 0x57, 0x98, 0x3a, 0xd7, 0xbc, 0x92,
	0xa2, 0x4a, 0x27, 0x96, 0x13, 0xf7, 0xe4, 0x19, 0x90, 0x1c, 0x2a, 0x65, 0xcd, 0xc5, 0x1a, 0x5c,
	0x92, 0x58, 0x92, 0x2a, 0x64, 0xc4, 0xc5, 0x96, 0x0a, 0xf2, 0x58, 0x31, 0xd4, 0x40, 0x11, 0x84,
	0x81, 0x08, 0x5f, 0x43, 0xf5, 0x43, 0x55, 0x4a, 0x45, 0x71, 0xf1, 0xa1, 0x9a, 0x2f, 0x24, 0xc0,
	0xc5, 0x0c, 0xf2, 0x1c, 0x24, 0x3c, 0x40, 0x4c, 0x21, 0x23, 0x2e, 0x56, 0x88, 0xaf, 0x40, 0x01,
	0xc1, 0x6d, 0x24, 0x83, 0xc3, 0x9d, 0x60, 0x47, 0x04, 0x41, 0x94, 0x5a, 0x31, 0x59, 0x30, 0x3a,
	0xf1, 0x9c, 0x78, 0x24, 0xc7, 0x78, 0xe1, 0x91, 0x1c, 0xe3, 0x82, 0xc7, 0x72, 0x8c, 0x49, 0x6c,
	0xe0, 0x28, 0x30, 0x06, 0x04, 0x00, 0x00, 0xff, 0xff, 0x16, 0xda, 0xa3, 0xc0, 0xcb, 0x01, 0x00,
	0x00,
}
